<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rabbitMq学习 | 杨凯的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="rabbitMq： 优点：解耦，异步，缓冲，伸缩性，扩展性 与Rpc的区别：Rpc同步，mq异步          rabbitMq概念： Broker:标识消息队列服务器实体。 Virtual Host：虚拟主机， 每个vhost本质上就是一个mini版的RabbitMQ服务器。 Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Queue:消息队列，用来保存">
<meta property="og:type" content="article">
<meta property="og:title" content="rabbitMq学习">
<meta property="og:url" content="http://example.com/2020/12/15/study/rabbitMq/index.html">
<meta property="og:site_name" content="杨凯的笔记">
<meta property="og:description" content="rabbitMq： 优点：解耦，异步，缓冲，伸缩性，扩展性 与Rpc的区别：Rpc同步，mq异步          rabbitMq概念： Broker:标识消息队列服务器实体。 Virtual Host：虚拟主机， 每个vhost本质上就是一个mini版的RabbitMQ服务器。 Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Queue:消息队列，用来保存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/截图.png">
<meta property="og:image" content="http://example.com/image/WechatIMG8525.png">
<meta property="og:image" content="http://example.com/image/WechatIMG8528.png">
<meta property="article:published_time" content="2020-12-15T02:40:38.000Z">
<meta property="article:modified_time" content="2021-02-23T09:39:43.348Z">
<meta property="article:author" content="yk">
<meta property="article:tag" content="MQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/截图.png">
  
    <link rel="alternate" href="/atom.xml" title="杨凯的笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨凯的笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">日习则学不忘，自勉则身不坠</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-study/rabbitMq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/study/rabbitMq/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:40:38.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      rabbitMq学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="rabbitMq："><a href="#rabbitMq：" class="headerlink" title="rabbitMq："></a>rabbitMq：</h2><blockquote>
<p>优点：解耦，异步，缓冲，伸缩性，扩展性</p>
<p>与Rpc的区别：Rpc同步，mq异步        </p>
</blockquote>
<h3 id="rabbitMq概念："><a href="#rabbitMq概念：" class="headerlink" title="rabbitMq概念："></a>rabbitMq概念：</h3><ul>
<li>Broker:标识消息队列服务器实体。</li>
<li>Virtual Host：虚拟主机， 每个vhost本质上就是一个mini版的RabbitMQ服务器。</li>
<li>Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li>
<li>Queue:消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>
<li>Banding：绑定，用于消息队列和交换机之间的关联，一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li>
<li>Channel：信道，多路复用连接中的一条独立的双向数据流通道</li>
</ul>
<h2 id="Exchange分发策略"><a href="#Exchange分发策略" class="headerlink" title="Exchange分发策略"></a>Exchange分发策略</h2><ul>
<li><p>direct:消息中的路由键如果和Binding中的binding key一致，交换器就将消息发到对应的队列中。路由键                                  与队列名完全匹配。(完全匹配)</p>
</li>
<li><p>fanout(广播):每个发到fanout类型交换器的消息都会分到所有绑定的队列上去</p>
</li>
<li><p>topic:必须由（.）分割的单词列表。比如apple.banana.orange</p>
<blockquote>
<p>可以代替一个单词。</p>
<p> #可以代替零个或多个单词。</p>
</blockquote>
</li>
</ul>
<img src="/image/截图.png" width="70%">

<h1 id="交换器（原生客户端）"><a href="#交换器（原生客户端）" class="headerlink" title="交换器（原生客户端）"></a>交换器（原生客户端）</h1><h3 id="Direct交换器："><a href="#Direct交换器：" class="headerlink" title="Direct交换器："></a>Direct交换器：</h3><h4 id="product"><a href="#product" class="headerlink" title="product:"></a>product:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接、连接到RabbitMQ</span></span><br><span class="line">ConnectionFactory connectionFactory= <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置下连接工厂的连接地址(使用默认端口5672)</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection =connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建信道</span></span><br><span class="line">Channel channel =connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_logs&quot;</span>,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明队列（放在消费者中去做）</span></span><br><span class="line"><span class="comment">//申明路由键\消息体</span></span><br><span class="line">String[] routeKeys =&#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    String routeKey = routeKeys[i%<span class="number">3</span>];</span><br><span class="line">    String msg = <span class="string">&quot;Hello,RabbitMQ&quot;</span>+(i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发布消息 </span></span><br><span class="line"> channel.basicPublish(<span class="string">&quot;direct_logs&quot;</span>,routeKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;Sent:&quot;</span>+routeKey+<span class="string">&quot;:&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer:"></a>consumer:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接、连接到RabbitMQ</span></span><br><span class="line">ConnectionFactory connectionFactory= <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置下连接工厂的连接地址(使用默认端口5672)</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection =connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建信道</span></span><br><span class="line">Channel channel =connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_logs&quot;</span>,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明队列（放在消费者中去做）</span></span><br><span class="line">String queueName=<span class="string">&quot;queue-a&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定：将队列(queuq-a)与交换器通过 路由键 绑定(aaa)</span></span><br><span class="line">String routeKey =<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">channel.queueBind(queueName,DirectProducer.EXCHANGE_NAME,routeKey);</span><br><span class="line">System.out.println(<span class="string">&quot;waiting for message ......&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明一个消费者</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer  = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String s, Envelope envelope, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()+<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消息者正是开始在指定队列上消费。(queue-a)</span></span><br><span class="line"><span class="comment">//TODO 这里第二个参数是自动确认参数，如果是true则是自动确认</span></span><br><span class="line">channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure>

<h3 id="fanout-交换器"><a href="#fanout-交换器" class="headerlink" title="fanout 交换器"></a>fanout 交换器</h3><p>routeKey无论设置为任何键，消息都会发到每一个队列</p>
<h3 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h3><blockquote>
<p> *与#的区别：如果我们发送的路由键变成king.kafka.A,那么队列中如果绑定了king.* 不能匹配队列中如果绑定了king.# 能够匹配</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 根据需求绑定不同routeKey</span></span><br><span class="line">channel.queueBind(queueName,TopicProducer.EXCHANGE_NAME, <span class="string">&quot;king.#&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="消息发布和消费的权衡"><a href="#消息发布和消费的权衡" class="headerlink" title="消息发布和消费的权衡"></a>消息发布和消费的权衡</h1><h2 id="发布时的权衡："><a href="#发布时的权衡：" class="headerlink" title="发布时的权衡："></a>发布时的权衡：</h2><p>在RabbitMQ 中，有不同的投递机制（生产者），但是每一种机制都对性能有一定的影响。一般来讲速度快的可靠性低，可靠性好的性能差，具体怎么使用需要根据你的应用程序来定，所以说没有最好的方式，只有最合适的方式。只有把你的项目和技术相结合，才能找到适合你的平衡。</p>
<img src="/image/WechatIMG8525.png" width="100%">

<h4 id="1-无保障："><a href="#1-无保障：" class="headerlink" title="1.无保障："></a>1.无保障：</h4><p><em>在演示各种交换器中使用的就是无保障的方式，通过basicPublish 发布你的消息并使用正确的交换器和路由信息，你的消息会被接收并发送到合适的队列中。但是如果有网络问题，或者消息不可路由，或者RabbitMQ 自身有问题的话，这种方式就有风险。所以无保证的消息发送一般情况下不推荐。</em></p>
<h4 id="2-失败确认"><a href="#2-失败确认" class="headerlink" title="2.失败确认"></a>2.失败确认</h4><p><em>在发送消息时设置mandatory 标志，告诉RabbitMQ，如果消息不可路由，应该将消息返回给发送者，并通知失败。可以这样认为，开启mandatory是开启故障检测模式。</em></p>
<blockquote>
<p>注意：它只会让RabbitMQ 向你通知失败，而不会通知成功。如果消息正确路由到队列，则发布者不会受到任何通知。带来的问题是无法确保发布消息一定是成功的，因为通知失败的消息可能会丢失。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//失败通知 回调</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replycode, String replyText, String exchange, String routeKey, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回的replycode:&quot;</span>+replycode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//TODO 第三个参数mandatory设置为true,开启故障检测模式 </span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,routekey,<span class="keyword">true</span>,<span class="keyword">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>

<h4 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h4><p><em>事务的实现主要是对信道（Channel）的设置，主要的方法有三个：</em></p>
<ol>
<li><p>channel.txSelect()声明启动事务模式；</p>
</li>
<li><p>channel.txComment()提交事务；</p>
</li>
<li><p>channel.txRollback()回滚事务；</p>
</li>
</ol>
<p><em>在发送消息之前，需要声明channel 为事务模式，提交或者回滚事务即可。开启事务后，客户端和RabbitMQ 之间的通讯交互流程：</em></p>
<ul>
<li><p>客户端发送给服务器Tx.Select(开启事务模式)</p>
</li>
<li><p>服务器端返回Tx.Select-Ok（开启事务模式ok）</p>
</li>
<li><p>推送消息</p>
</li>
<li><p>客户端发送给事务提交Tx.Commit</p>
</li>
<li><p> 服务器端返回Tx.Commit-Ok</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入事务</span></span><br><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        String routekey = routekeys[i%<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 发送的消息</span></span><br><span class="line">        String message = <span class="string">&quot;Hello World_&quot;</span>+(i+<span class="number">1</span>)</span><br><span class="line">                +(<span class="string">&quot;_&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routekey, <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: [&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事务提交</span></span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="comment">//事务回滚</span></span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么，既然已经有事务了，为何还要使用发送方确认模式呢，原因是因为事务的性能是非常差的。根据相关资料，事务会降低2~10 倍的性能。</p>
</blockquote>
<h4 id="4-发送发确认模式："><a href="#4-发送发确认模式：" class="headerlink" title="4.发送发确认模式："></a>4.发送发确认模式：</h4><p><em>基于事务的性能问题，RabbitMQ 团队为我们拿出了更好的方案，即采用发送方确认模式，该模式比事务更轻量，性能影响几乎可以忽略不计。原理：生产者将信道设置成confirm 模式，一旦信道进入confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1 开始)，由这个id 在生产者和RabbitMQ 之间进行消息的确认。不可路由的消息，当交换器发现，消息不能路由到任何队列，会进行确认操作，表示收到了消息。如果发送方设置了mandatory 模式,则会先调用addReturnListener 监听器。</em></p>
<p><em>可路由的消息，要等到消息被投递到所有匹配的队列之后，broker 会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中delivery-tag 域包含了确认消息的序列号。</em></p>
<p><em>confirm 模式最大的好处在于他可以是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack 消息，生产者应用程序同样可以在回调方法中处理该nack 消息决定下一步的处理。</em></p>
<h5 id="Confirm-的三种实现方式："><a href="#Confirm-的三种实现方式：" class="headerlink" title="Confirm 的三种实现方式："></a>Confirm 的三种实现方式：</h5><ul>
<li>方式一：channel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//确认是否成功(true成功)</span></span><br><span class="line"><span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;send success&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;send failure&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：channel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException 异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式（批量确认）</span></span><br><span class="line">channel.waitForConfirmsOrDie();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方式三：channel.addConfirmListener()异步监听发送方确认模式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO启用发送者确认模式 </span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//TODO添加发送者确认监听器</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">    <span class="comment">//TODO 成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;     System.out.println(<span class="string">&quot;send_ACK:&quot;</span>+deliveryTag+<span class="string">&quot;,multiple:&quot;</span>+multiple);&#125;</span><br><span class="line">    <span class="comment">//TODO 失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Erro----send_NACK:&quot;</span>+deliveryTag+<span class="string">&quot;,multiple:&quot;</span>+multiple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-备用交换器"><a href="#5-备用交换器" class="headerlink" title="5.备用交换器"></a>5.备用交换器</h4><p><em>在第一次声明交换器时被指定，用来提供一种预先存在的交换器，如果主交换器无法路由消息，那么消息将被路由到这个新的备用交换器。使用备用交换器，向往常一样，声明Queue 和备用交换器，把Queue 绑定到备用交换器上。然后在声明主交换器时，通过交换器的参数，alternate-exchange,，将备用交换器设置给主交换器。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明备用交换器</span></span><br><span class="line">Map&lt;String,Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">argsMap.put(<span class="string">&quot;alternate-exchange&quot;</span>,<span class="string">&quot;ae&quot;</span>);</span><br><span class="line"><span class="comment">//主交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;main-exchange&quot;</span>,<span class="string">&quot;direct&quot;</span>,</span><br><span class="line">        <span class="keyword">false</span>,<span class="keyword">false</span>,argsMap);</span><br><span class="line"><span class="comment">//备用交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;ae&quot;</span>,BuiltinExchangeType.FANOUT,</span><br><span class="line">        <span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="消息的消费权衡"><a href="#消息的消费权衡" class="headerlink" title="消息的消费权衡"></a>消息的消费权衡</h2><img src="/image/WechatIMG8528.png" width="80%">

<h3 id="消息的获取方式"><a href="#消息的获取方式" class="headerlink" title="消息的获取方式"></a>消息的获取方式</h3><h4 id="拉取Get"><a href="#拉取Get" class="headerlink" title="拉取Get"></a>拉取Get</h4><p>_属于一种轮询模型，发送一次get 请求，获得一个消息。如果此时RabbitMQ 中没有消息，会获得一个表示空的回复。总的来说，这种方式性能比较差，很明显，每获得一条消息，都要和RabbitMQ 进行网络通信发出请求。而且对RabbitMQ 来说，RabbitMQ 无法进行任何优化，因为它永远不知道应用程序何时会发出请求。具体使用，参见代码native 模块包cn.enjoyedu.consumer_balance.GetMessage 中。对我们实现者来说，要在一个循环里，不断去服务器get 消息。_</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 无限循环拉取</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//拉一条，自动确认的(rabbit 认为这条消息消费 -- 从队列中删除)</span></span><br><span class="line">    GetResponse getResponse = channel.basicGet(queueName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>!=getResponse)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;received[&quot;</span></span><br><span class="line">                +getResponse.getEnvelope().getRoutingKey()+<span class="string">&quot;]&quot;</span></span><br><span class="line">                +<span class="keyword">new</span> String(getResponse.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确认(自动、手动)</span></span><br><span class="line">    channel.basicAck(<span class="number">0</span>,<span class="keyword">true</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="推送Consume"><a href="#推送Consume" class="headerlink" title="推送Consume"></a>推送Consume</h4><p><em>属于一种推送模型。注册一个消费者后，RabbitMQ 会在消息可用时，自动将消息进行推送给消费者。</em></p>
<h4 id="消息的应答"><a href="#消息的应答" class="headerlink" title="消息的应答"></a>消息的应答</h4><p><em>前面说过，消费者收到的每一条消息都必须进行确认。消息确认后，RabbitMQ 才会从队列删除这条消息，RabbitMQ 不会为未确认的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是<strong>消费该消息的消费者连接是否已经断开</strong>。这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</em></p>
<h4 id="自动确认"><a href="#自动确认" class="headerlink" title="自动确认"></a>自动确认</h4><p><em>消费者在声明队列时，可以指定autoAck 参数，当autoAck=true 时，一旦消费者接收到了消息，就视为自动确认了消息。如果消费者在处理消息的过程中，出了错，就没有什么办法重新处理这条消息，所以我们很多时候，需要在消息处理成功后，再确认消息，这就需要手动确认。</em></p>
<h4 id="手动确认"><a href="#手动确认" class="headerlink" title="手动确认"></a>手动确认</h4><p>​        <em>当autoAck=false 时，RabbitMQ 会等待消费者显式发回ack 信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ 会在队列中消息被消费后立即删除它。</em>    </p>
<p>​        <em>采用消息确认机制后，只要令autoAck=false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ 会一直持有消息直到消费者显式调用basicAck 为止。</em></p>
<p>​        <em>当autoAck=false 时，对于RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者ack 信号的消息。如果服务器端一直没有收到消费者的ack 信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*声明了一个消费者*/</span></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params"> Envelope envelope,AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);                   System.out.println(<span class="string">&quot;Received&quot;</span>+message);</span><br><span class="line">                    <span class="comment">//确认</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//拒绝</span></span><br><span class="line"><span class="comment">//Reject方式拒绝，第二个参数决定是否重新投递</span></span><br><span class="line">channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*消费者正式开始在指定队列上消费消息*/</span></span><br><span class="line">        <span class="comment">//TODO 这里第二个参数是自动确认参数，如果是false则是手动确认</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">false</span>,consumer);</span><br></pre></td></tr></table></figure>

<h4 id="QoS-预取模式"><a href="#QoS-预取模式" class="headerlink" title="QoS 预取模式"></a>QoS 预取模式</h4><p><em>在确认消息被接收之前，消费者可以预先要求接收一定数量的消息，在处理完一定数量的消息后，批量进行确认。如果消费者应用程序在确认消息之前崩溃，则所有未确认的消息将被重新发送给其他消费者。所以这里存在着一定程度上的可靠性风险。这种机制一方面可以实现限速（将消息暂存到RabbitMQ 内存中）的作用，一方面可以保证消息确认质量（比如确认了但是处理有异常的情况）。</em></p>
<blockquote>
<p>注意：消费确认模式必须是非自动ACK 机制（这个是使用baseQos 的前提条件，否则会Qos 不生效），然后设置basicQos 的值；另外，还可以基于consume 和channel 的粒度进行设置（global）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量确认 -----消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchAckConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计数，第多少条</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> meesageCount =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchAckConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消费者启动了......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">      Envelope envelope,AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//把消息体拉出来</span></span><br><span class="line">        String message = <span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> System.out.println(message);</span><br><span class="line">        meesageCount++;</span><br><span class="line">        <span class="comment">//批量确认 50一批</span></span><br><span class="line">        <span class="keyword">if</span>(meesageCount %<span class="number">50</span> ==<span class="number">0</span>)&#123;        <span class="keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;批量消息费进行消息的确认------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果是最后一条消息，则把剩余的消息都进行确认</span></span><br><span class="line">       <span class="keyword">if</span>(message.equals(<span class="string">&quot;stop&quot;</span>))&#123;         <span class="keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;批量消费者进行最后业务消息的确认---------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息的拒绝"><a href="#消息的拒绝" class="headerlink" title="消息的拒绝"></a>消息的拒绝</h2><blockquote>
<p>Reject 和 N a c k  </p>
</blockquote>
<p>​        消息确认可以让RabbitMQ 知道消费者已经接受并处理完消息。但是如果消息本身或者消息的处理过程出现问题怎么办？需要一种机制，通知RabbitMQ，这个消息，我无法处理，请让别的消费者处理。这里就有两种机制，Reject 和Nack。Reject 在拒绝消息时，可以使用requeue 标识，告诉RabbitMQ 是否需要重新发送给别的消费者。如果是false 则不重新发送，一般这个消息就会被RabbitMQ 丢弃。Reject 一次只能拒绝一条消息。如果是true 则消息发生了重新投递。</p>
<p>​        Nack 跟Reject 类似，只是它可以一次性拒绝多个消息。也可以使用requeue 标识，这是RabbitMQ 对AMQP 规范的一个扩展。具体使用，当requeue参数设置为true 时，消息发生了重新投递。当requeue 参数设置为false 时，消息丢失了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reject方式拒绝，第二个参数决定是否重新投递</span></span><br><span class="line">channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">true</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//Nack方式拒绝，第二个参数决定是否批量,第三参数是否重新投递</span></span><br><span class="line">channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="死信交换器（DLX）"><a href="#死信交换器（DLX）" class="headerlink" title="死信交换器（DLX）"></a>死信交换器（DLX）</h2><blockquote>
<p>1.过期消息</p>
<p>2.消息队列达到最大长度，最开始的投递的消息</p>
<p>3.拒绝且requeue = false的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定死信交换器</span></span><br><span class="line">channel.exchageDeclare(DlxProducer.EXCHAGE_NAME, BuiltinExchageType.TOPIC);</span><br><span class="line"><span class="comment">//申明队列</span></span><br><span class="line">String queueName = <span class="string">&quot;dlx_make&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchage&quot;</span>, <span class="string">&quot;死信交换器名称&quot;</span>);</span><br><span class="line"><span class="comment">//TODO 死信路由键会替换原来路由键</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,args);</span><br><span class="line"><span class="comment">//将队列和交换器通过路由键绑定</span></span><br><span class="line">channel.queueBind(queueName,DlxProducer.EXCHAGE_NAME, <span class="string">&quot;#&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="死信交换器和备用交换器的区别"><a href="#死信交换器和备用交换器的区别" class="headerlink" title="死信交换器和备用交换器的区别"></a><strong>死信交换器和备用交换器的区别</strong></h4><blockquote>
<p>备用交换器是备胎：没有队列要它的时候只能选择备用交换器。死信交换器是老实人：消息已经被消费者玩过一遍，消费者没有消费，只能被死信交换器接收。</p>
</blockquote>
<h3 id="控制队列"><a href="#控制队列" class="headerlink" title="控制队列"></a>控制队列</h3><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><p><em>临时队列对应的是没有持久化的队列，也就是如果RabbitMQ 服务器重启，那么这些队列就不会存在，所以我们称之为临时队列。</em></p>
<h4 id="自动删除队列"><a href="#自动删除队列" class="headerlink" title="自动删除队列"></a>自动删除队列</h4><p><em>自动删除队列和普通队列在使用上没有什么区别，唯一的区别是，当消费者断开连接时，队列将会被删除。自动删除队列允许的消费者没有限制，也就是说当这个队列上最后一个消费者断开连接才会执行删除。</em></p>
<blockquote>
<p>自动删除队列只需要在声明队列时，设置属性auto-delete 标识为true 即可。系统声明的随机队列，缺省就是自动删除的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四个参数</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="单消费者队列"><a href="#单消费者队列" class="headerlink" title="单消费者队列"></a>单消费者队列</h4><p><em>普通队列允许的消费者没有限制，多个消费者绑定到多个队列时，RabbitMQ 会采用轮询进行投递。如果需要消费者独占队列，在队列创建的时候，设定属性exclusive 为true。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自动过期队列"><a href="#自动过期队列" class="headerlink" title="自动过期队列"></a>自动过期队列</h4><p><em>指队列在超过一定时间没使用，会被从RabbitMQ 中被删除。</em></p>
<p><em>什么是没使用？1.一定时间内没有Get 操作发生。2.没有Consumer 连接在队列上。特别的：就算一直有消息进入队列，也不算队列在被使用。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO /*自动过期队列--参数需要Map传递*/</span></span><br><span class="line">String queueName = <span class="string">&quot;setQueue&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-expires&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//10秒被删除</span></span><br><span class="line"><span class="comment">//TODO 队列的各种参数</span></span><br><span class="line"><span class="comment">/*加入队列的各种参数*/</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,arguments);</span><br></pre></td></tr></table></figure>

<h4 id="永久队列"><a href="#永久队列" class="headerlink" title="永久队列"></a>永久队列</h4><p><em>持久化队列和非持久化队列的区别是，持久化队列会被保存在磁盘中，固定并持久的存储，当Rabbit 服务重启后，该队列会保持原来的状态在RabbitMQ中被管理，而非持久化队列不会被保存在磁盘中，Rabbit 服务重启后队列就会消失。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将属性durable 设置为“true”，</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="队列级别消息过期"><a href="#队列级别消息过期" class="headerlink" title="队列级别消息过期"></a>队列级别消息过期</h4><p><em>就是为每个队列设置消息的超时时间。只要给队列设置x-message-ttl 参数，就设定了该队列所有消息的存活时间，时间单位是毫秒。如果声明队列时指定了死信交换器，则过期消息会成为死信消息。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO /*自动过期队列--参数需要Map传递*/</span></span><br><span class="line">String queueName = <span class="string">&quot;setQueue&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-expires&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//10秒被删除</span></span><br><span class="line"><span class="comment">//设定该队列消息存活时间，时间单位毫秒</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//消息10秒被删除</span></span><br><span class="line"><span class="comment">//TODO 队列的各种参数</span></span><br><span class="line"><span class="comment">/*加入队列的各种参数*/</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,arguments);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对队列中消息的条数进行限制x-max-length</p>
</li>
<li><p>对队列中消息的总量进行限制x-max-length-bytes</p>
</li>
</ul>
<h3 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h3><p><em>默认情况下，队列和交换器在服务器重启后都会消失，消息当然也是。将队列和交换器的durable 属性设为true，缺省为false，但是消息要持久化还不够，还需要将消息在发布前，将投递模式设置为2。消息要持久化，必须要有持久化的队列、交换器和投递模式都为2。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 创建持久化交换器 durable=true</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;direct&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//TODO 发布持久化的消息(delivery-mode=2)</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,routekey,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        msg.getBytes());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 声明一个持久化队列(durable=true)</span></span><br><span class="line">String queueName = <span class="string">&quot;msgdurable&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,</span><br><span class="line">        <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Request-Response-模式"><a href="#Request-Response-模式" class="headerlink" title="Request-Response 模式"></a>Request-Response 模式</h3><p>​        <em>我们前面的学习模式中都是一方负责发送消息而另外一方负责处理。而我们实际中的很多应用相当于一种一应一答的过程，需要双方都能给对方发送消息。于是请求-应答的这种通信方式也很重要。它也应用的很普遍。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 响应QueueName ，消费者将会把要返回的信息发送到该Queue</span></span><br><span class="line">String responseQueue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//TODO 消息的唯一id</span></span><br><span class="line">String msgId = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//TODO 设置消息中的应答属性</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">  <span class="comment">//replyTO构建回复消息的私有响应队列</span></span><br><span class="line">        .replyTo(responseQueue)</span><br><span class="line">        .messageId(msgId)</span><br><span class="line">        .build();</span><br><span class="line"> <span class="comment">/*声明了一个消费者*/</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()</span><br><span class="line">                        +<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//TODO 消费者应答队列上的消息</span></span><br><span class="line">channel.basicConsume(responseQueue,<span class="keyword">true</span>,consumer);</span><br><span class="line"> String msg = <span class="string">&quot;Hello,RabbitMq&quot;</span>;</span><br><span class="line"> <span class="comment">//TODO 发送消息时，把响应相关属性设置进去</span></span><br><span class="line"> channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>,properties,</span><br><span class="line">          msg.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;Sent error:&quot;</span>+msg);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绑定，将队列和交换器通过路由键进行绑定*/</span></span><br><span class="line">String routekey = <span class="string">&quot;error&quot;</span>;<span class="comment">/*表示只关注error级别的日志消息*/</span></span><br><span class="line">channel.queueBind(queueName,ReplyToProducer.EXCHANGE_NAME,routekey);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;waiting for message........&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明了一个消费者*/</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                               AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()</span><br><span class="line">                +<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">        <span class="comment">//TODO 从消息中拿到相关属性（确定要应答的消息ID,）</span></span><br><span class="line">        AMQP.BasicProperties respProp</span><br><span class="line">                = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .replyTo(properties.getReplyTo())</span><br><span class="line">                .correlationId(properties.getMessageId())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//TODO 消息消费时，同时需要生作为生产者生产消息（以OK为标识）</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, respProp.getReplyTo() ,</span><br><span class="line">                respProp ,</span><br><span class="line">                (<span class="string">&quot;OK,&quot;</span>+message).getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*消费者正式开始在指定队列上消费消息*/</span></span><br><span class="line">channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/study/rabbitMq/" data-id="cklhti87n000y0govbb8t8y4z" data-title="rabbitMq学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/15/study/RocketMQ/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          rocketMq学习
        
      </div>
    </a>
  
  
    <a href="/2020/12/15/%E4%B8%80%E4%B8%AAhexo%E7%9A%84%E7%A4%BA%E4%BE%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">一个hexo的示例</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/study/">study</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mycat/" rel="tag">mycat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/mycat/" style="font-size: 15px;">mycat</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/25/study/mysql4/">mysql索引</a>
          </li>
        
          <li>
            <a href="/2021/02/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/02/23/study/mysql3/">mysql事务隔离</a>
          </li>
        
          <li>
            <a href="/2021/02/19/study/mysql2/">一条更新sql是如何执行的</a>
          </li>
        
          <li>
            <a href="/2021/01/23/study/jvm1/">jvm认识-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 yk<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>