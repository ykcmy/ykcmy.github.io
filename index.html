<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>杨凯的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="333333333333">
<meta property="og:type" content="website">
<meta property="og:title" content="杨凯的笔记">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="杨凯的笔记">
<meta property="og:description" content="333333333333">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yk">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="杨凯的笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨凯的笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">日习则学不忘，自勉则身不坠</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/23/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-02-23T07:21:02.415Z" itemprop="datePublished">2021-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/23/hello-world/" data-id="cklhojuy000000csxawy69zi8" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/23/study/mysql3/" class="article-date">
  <time class="dt-published" datetime="2021-02-23T03:57:38.000Z" itemprop="datePublished">2021-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/23/study/mysql3/">mysql事务隔离</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p>
<ul>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<img src="/image/mysql3.1.png" width="80%">

<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<h1 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h1><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li>
<li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p>
<p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p>
<p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/23/study/mysql3/" data-id="cklhojuyi000c0csx8825e8l1" data-title="mysql事务隔离" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/19/study/mysql2/" class="article-date">
  <time class="dt-published" datetime="2021-02-19T03:41:38.000Z" itemprop="datePublished">2021-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/19/study/mysql2/">一条更新sql是如何执行的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将ID=2这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c&#x3D;c+1 where ID&#x3D;2; </span><br></pre></td></tr></table></figure>

<p>前面我有跟你介绍过SQL语句基本的执行链路。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h1 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h1><p><strong>WAL技术</strong>（Write-Ahead Logging）：</p>
<p>它的关键点就是先写日志，再写磁盘。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<img src="/image/mysql2.1.jpg" width="80%">

<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h1 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h1><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li><p>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</p>
<img src="/image/mysql2.2.png" width="80%">

<p>​                                                        update语句执行流程</p>
</li>
</ol>
<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>
<h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ol>
<li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li>
<li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p>
<p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p>
<p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/19/study/mysql2/" data-id="cklhojuyg00080csx0la55fl9" data-title="一条更新sql是如何执行的" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/jvm1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/23/study/jvm1/" class="article-date">
  <time class="dt-published" datetime="2021-01-23T07:41:38.000Z" itemprop="datePublished">2021-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/23/study/jvm1/">jvm认识-1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="Java-虚拟机具体是怎样运行-Java-字节码的？"><a href="#Java-虚拟机具体是怎样运行-Java-字节码的？" class="headerlink" title="Java 虚拟机具体是怎样运行 Java 字节码的？"></a>Java 虚拟机具体是怎样运行 Java 字节码的？</h4><p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟<br>机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执<br>行方法区内的代码。</p>
<p>如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同<br>样也在内存中划分出堆和栈来存储运行时数据。</p>
<p>不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用<br>C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。</p>
<p><img src="/image/jvm1.1.png" alt="image-20210223135452884"></p>
<p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中<br>生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，<br>而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p>
<p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程<br>的当前栈帧，并将之舍弃。</p>
<p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器<br>码。</p>
<p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成<br>机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中<br>包含的所有字节码编译成机器码后再执行。</p>
<p><img src="/image/jvm1.2.png" alt="image-20210223135652372"></p>
<p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用<br>混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反<br>复执行的热点代码，以方法为单位进行即时编译。</p>
<h4 id="Java虚拟机是如何加载Java类的"><a href="#Java虚拟机是如何加载Java类的" class="headerlink" title="Java虚拟机是如何加载Java类的?"></a>Java虚拟机是如何加载Java类的?</h4><p><strong>加载</strong></p>
<p>加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对<br>应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助<br>类加载器来完成查找字节流的过程。</p>
<p>启动类加载器（bootstrapclass loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中，只能用 null 来指代。</p>
<p>除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应<br>的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java<br>虚拟机中，方能执行类加载。</p>
<p>双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p>
<p>在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib<br>目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载<br>器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加<br>载器（application class loader），均由 Java 核心类库提供。</p>
<p>扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存<br>放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。</p>
<p>应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的<br>应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量<br>CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载<br>的。</p>
<p>Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类<br>加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base<br>是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p>
<p>除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊<br>的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器。</p>
<p><strong>链接</strong></p>
<p>链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准<br>备以及解析三个阶段。</p>
<p>验证：验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。</p>
<p>准备：准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初<br>始化，则会在稍后的初始化阶段中进行。</p>
<p>除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如<br>说用来实现虚方法的动态绑定的方法表。</p>
<p>在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的<br>具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编<br>译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标<br>上。</p>
<p>解析： 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载<br>的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的<br>链接以及初始化。）</p>
<p><strong>初始化</strong></p>
<p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态<br>代码块中对其赋值。</p>
<p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字<br>段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完<br>成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同<br>一方法中，并把它命名为 &lt; clinit &gt;。</p>
<p>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的<br>过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。</p>
<p>那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p>
<ol>
<li>当虚拟机启动时，初始化用户指定的主类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，<br>会触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ol>
<p>Q:</p>
<p>1:为什么使用JVM？<br>1-1:可以轻松实现Java代码的跨平台执行<br>1-2:JVM提供了一个托管平台，提供内存管理、垃圾回收、编译时动态校验等功能<br>1-3:使用JVM能够让我们的编程工作更轻松、高效节省公司成本，提示社会化的整体快发效率，我们只关注和业务相关的程序逻辑的编写，其他业务无关但对于编程同样重要的事情交给JVM来处理</p>
<p>2.热点代码和非热点代码：</p>
<p>看到有人说热点代码的区别，在git里面涉及到的热点代码有两种算法，基于采样的热点探测和基于计数器的热点探测。一般采用的都是基于计数器的热点探测，两者的优缺点百度一下就知道了。基于计数器的热点探测又有两个计数器，方法调用计数器，回边计数器，他们在C1和C2又有不同的阈值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/23/study/jvm1/" data-id="cklhojuya00020csxetnq1bui" data-title="jvm认识-1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/22/study/mysql1/" class="article-date">
  <time class="dt-published" datetime="2021-01-22T03:41:38.000Z" itemprop="datePublished">2021-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/22/study/mysql1/">一条sql是如何执行的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p>
<img src="/image/mysql1.1.png" width="80%">

<p>​                                                                        mysql 的逻辑架构图</p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。</p>
<h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <strong>Lost connection to MySQL server during query</strong>。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用<strong>长连接</strong>。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为<strong>MySQL在执行过程中临时使用的内存是管理在连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<ol>
<li><strong>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</strong></li>
<li><strong>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</strong></li>
</ol>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID&#x3D;10；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID&#x3D;1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
<h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c&#x3D;10 and t2.d&#x3D;20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID&#x3D;10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/22/study/mysql1/" data-id="cklhojuyf00070csxawafamgh" data-title="一条sql是如何执行的" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mycat分库分表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/study/mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:40:38.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/15/study/mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">分库分表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="分库分表方案选型"><a href="#分库分表方案选型" class="headerlink" title="分库分表方案选型"></a>分库分表方案选型</h2><h4 id="方案背景："><a href="#方案背景：" class="headerlink" title="方案背景："></a>方案背景：</h4><blockquote>
<p>当项目随公司业务以及时间的发展，数据量相应就会增加，当单库的并发达到2000以上，或者单表的数据量达到千万级别，那么这个时候分库（分表）就不可避免，这篇文章主要调研市面上针对分库分表的方案，为后期分库分表做铺垫。</p>
</blockquote>
<h5 id="何为数据切分："><a href="#何为数据切分：" class="headerlink" title="何为数据切分："></a>何为数据切分：</h5><p>简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存<br>放到多个数据库（主机）上面，以达到分散单台设备负载的效果。<br> 数据切分分为两种：</p>
<h6 id="垂直切分，-水平切分"><a href="#垂直切分，-水平切分" class="headerlink" title="垂直切分， 水平切分"></a>垂直切分， 水平切分</h6><h5 id="垂直切分优缺点："><a href="#垂直切分优缺点：" class="headerlink" title="垂直切分优缺点："></a>垂直切分优缺点：</h5><p> 优点：</p>
<ul>
<li>数据库的拆分简单明了，拆分规则明确；</li>
<li>应用程序模块清晰明确，整合容易；</li>
<li>数据维护方便易行，容易定位；</li>
</ul>
<p>缺点：</p>
<ul>
<li>部分表关联无法在数据库级别完成，需要在程序中完成，存在跨库join的问题，对于这类的<br>表，就需要去做平衡，是数据库让步业务，共用一个数据源，还是分成多个库，业务之间通<br>过接口来做调用；在系统初期，数据量比较少，或者资源有限的情况下，会选择共用数据源<br>，但是当数据发展到了一定的规模，负载很大的情况，就需要必须去做分割；</li>
<li>对于访问极其频繁且数据量超大的表仍然存在性能瓶颈，不一定能满足要求；</li>
<li>事务处理相对更为复杂；</li>
<li>切分达到一定程度之后，扩展性会遇到限制；</li>
<li>过多切分可能会带来系统过渡复杂而难以维护。</li>
</ul>
<h5 id="水平拆分："><a href="#水平拆分：" class="headerlink" title="水平拆分："></a>水平拆分：</h5><p>相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中<br>，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分<br>，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库</p>
<p>优点：</p>
<ul>
<li> 表关联基本能够在数据库端全部完成；</li>
<li> 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题；</li>
<li> 应用程序端整体架构改动相对较少；</li>
<li> 事务处理相对简单；</li>
<li> 只要切分规则能够定义好，基本上较难遇到扩展性限制；</li>
</ul>
<p>缺点：</p>
<ul>
<li> 切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则；</li>
<li> 后期数据的维护难度有所增加，人为手工定位数据更困难；</li>
<li> 应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。</li>
<li> 跨节点合并排序分页问题</li>
<li> 多数据源管理问题</li>
</ul>
<h5 id="几种典型的分片规则："><a href="#几种典型的分片规则：" class="headerlink" title="几种典型的分片规则："></a>几种典型的分片规则：</h5><ul>
<li>按照tenantId 求模，将数据分散到不同的数据库，具有相同数据用户的数<br>据都被分散到一个库中。</li>
<li>按照日期，将不同月甚至日的数据分散到不同的库中。</li>
<li>按照某个特定的字段求摸，或者根据特定范围段分散到不同的库中</li>
</ul>
<h5 id="数据切分参考："><a href="#数据切分参考：" class="headerlink" title="数据切分参考："></a>数据切分参考：</h5><p>第一原则：能不切分尽量不要切分。<br>第二原则：如果要切分一定要选择合适的切分规则，提前规划好。<br>第三原则：数据切分尽量通过数据冗余或表分组（Table Group）来降低跨库Join的可能。<br>第四原则：由于数据库中间件对数据Join实现的优劣难以把握，而且实现高性能难度极<br>大，业务读取尽量少使用多表Join。</p>
<blockquote>
<p>综上描述，数据切分带来的核心问题主要有三个：<br> 引入分布式事务的问题；<br> 跨节点Join 的问题；<br> 跨节点合并排序分页问题；</p>
</blockquote>
<h2 id="数据库代理中间件选型："><a href="#数据库代理中间件选型：" class="headerlink" title="数据库代理中间件选型："></a>数据库代理中间件选型：</h2><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><ul>
<li>是一个数据库代理</li>
<li>MySQL、SQL Server、Oracle、DB2等主流数据库，也支持MongoDB这种新型NoSQL方式的存储</li>
<li>Mycat并不存储数据，只做数据路由</li>
</ul>
<p>Mycat的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的SQL语句，首先<br>对SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，<br>然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户</p>
<img src="/image/2020-08-26_5f45cbadcab17.png">


<h4 id="Mycat中间件配置："><a href="#Mycat中间件配置：" class="headerlink" title="Mycat中间件配置："></a>Mycat中间件配置：</h4><ul>
<li>1.逻辑库配置：<br>server.xml:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>******<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>avengers<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
schemas.xml:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;avengers&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn1,localdn2&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--mycat中的逻辑表--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		name:逻辑表的名称，名称必须唯一</span></span><br><span class="line"><span class="comment">		dataNode:值必须跟dataNode标签中的name对应，如果值过多可以用 dataNode=&quot;dn$0-99,cn$100-199&quot;</span></span><br><span class="line"><span class="comment">		rule:分片规则配置，定义在rule.xml中，必须与tableRule中的name对应</span></span><br><span class="line"><span class="comment">		ruleRequired:该属性用于指定表是否绑定分片规则，如果配置为true，但没有配置具体rule的话 ，程序会报错</span></span><br><span class="line"><span class="comment">		primaryKey：该逻辑表对应真实表的主键，例如：分片的规则是使用非主键进行分片的，那么在使用主键查询的时候，就会发送查询语句到所有配置的DN上，如果使用该属性配置真实表的主键。难么MyCat会缓存主键与具体DN的信息，那么再次使用非主键进行查询的时候就不会进行广播式的查询，就会直接发送语句给具体的DN，但是尽管配置该属性，如果缓存并没有命中的话，还是会发送语句给具体的DN，来获得数据</span></span><br><span class="line"><span class="comment">		type：全局表：global  每一个dn都会保存一份全局表，普通表：不指定该值为globla的所有表</span></span><br><span class="line"><span class="comment">		autoIncrement:autoIncrement=“true”,默认是禁用的</span></span><br><span class="line"><span class="comment">		needAddLimit：默认是true</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t_order&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;localdn&quot;</span> <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span> <span class="attr">subTables</span>=<span class="string">&quot;t_order$1-3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;table name=&quot;mycat_sequence&quot; dataNode=&quot;localdn&quot; primaryKey=&quot;name&quot;/&gt;--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- &lt;dataNode name=&quot;dn1$0-743&quot; dataHost=&quot;localhost1&quot; database=&quot;db$0-743&quot;</span></span><br><span class="line"><span class="comment">		/&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;localdn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;consult&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;localdn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;consult&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	maxCon:指定每个读写实例连接池的最大连接。也就是说，标签内嵌套的writeHost、readHost标签都会使用这个属性的值来实例化出连接池的最大连接数</span></span><br><span class="line"><span class="comment">	minCon:指定每个读写实例连接池的最小连接，初始化连接池的大小</span></span><br><span class="line"><span class="comment">	balance:</span></span><br><span class="line"><span class="comment"> balance=&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost上。</span></span><br><span class="line"><span class="comment"> balance=&quot;1&quot;，全部的readHost与stand by writeHost参与select语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且M1与 M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡。</span></span><br><span class="line"><span class="comment"> balance=&quot;2&quot;，所有读操作都随机的在writeHost、readhost上分发。</span></span><br><span class="line"><span class="comment"> balance=&quot;3&quot;，所有读请求随机的分发到writeHost对应的readhost执行，writerHost不负担读压力，注意balance=3只在1.4及其以后版本有，1.3没有。</span></span><br><span class="line"><span class="comment">	writeType:</span></span><br><span class="line"><span class="comment">	负载均衡类型，目前的取值有3种：</span></span><br><span class="line"><span class="comment"> writeType=&quot;0&quot;, 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties .</span></span><br><span class="line"><span class="comment">writeType=&quot;1&quot;，所有写操作都随机的发送到配置的writeHost。</span></span><br><span class="line"><span class="comment"> writeType=&quot;2&quot;，没实现</span></span><br><span class="line"><span class="comment">	switchType:</span></span><br><span class="line"><span class="comment">  - 表示不自动切换</span></span><br><span class="line"><span class="comment">    默认值，自动切换</span></span><br><span class="line"><span class="comment">    基于MySQL主从同步的状态决定是否切换</span></span><br><span class="line"><span class="comment">      心跳语句为 show slave status</span></span><br><span class="line"><span class="comment">    基于MySQL galary cluster的切换机制（适合集群）（1.4.1）</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--heartbeat标签</span></span><br><span class="line"><span class="comment">		MYSQL可以使用select user()</span></span><br><span class="line"><span class="comment">		Oracle可以使用select 1 from dual</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">connectionInitSql</span>&gt;</span><span class="tag">&lt;/<span class="name">connectionInitSql</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		如果writeHost指定的后端数据库宕机，那么这个writeHost绑定的所有readHost都将不可用。另一方面，由于这个writeHost宕机系统会自动的检测到，并切换到备用的writeHost上去</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--heartbeat标签</span></span><br><span class="line"><span class="comment">		MYSQL可以使用select user()</span></span><br><span class="line"><span class="comment">		Oracle可以使用select 1 from dual</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">connectionInitSql</span>&gt;</span><span class="tag">&lt;/<span class="name">connectionInitSql</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		如果writeHost指定的后端数据库宕机，那么这个writeHost绑定的所有readHost都将不可用。另一方面，由于这个writeHost宕机系统会自动的检测到，并切换到备用的writeHost上去</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3307&quot;</span> 			 <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="MyCat-分片规则"><a href="#MyCat-分片规则" class="headerlink" title="MyCat 分片规则"></a>MyCat 分片规则</h3><p>参考：<a target="_blank" rel="noopener" href="http://www.mycat.io/document/Mycat_V1.6.0.pdf">http://www.mycat.io/document/Mycat_V1.6.0.pdf</a></p>
<h4 id="根据id取模分片规则："><a href="#根据id取模分片规则：" class="headerlink" title="根据id取模分片规则："></a>根据id取模分片规则：</h4><p>rule.xml </p>
<blockquote>
<p>PartitionByMod需要 分片id必须能够转换为数字<br>PartitionByHashMod  根据分片id hash,所以并不强制要求 column 的数据类型是数字，也可以是字符型</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>tenant_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="固定hash分片："><a href="#固定hash分片：" class="headerlink" title="固定hash分片："></a>固定hash分片：</h4><p>rule.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>province<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--type默认值为0，0表示Integer，非零表示String--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--defaultNode 默认节点：小于0表示不设置默认节点，大于等于0表示设置默认节点,不能解析的枚举就存到默认节点--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>partition-hash-int.txt：</p>
<blockquote>
<p>tenantId = 0</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">234234234214231423=0</span><br><span class="line">784656757853535643=1</span><br><span class="line">345451423534645645=0</span><br><span class="line">895784654345431245=1</span><br><span class="line">563457651435234632=1</span><br><span class="line">534534567587588567=1</span><br></pre></td></tr></table></figure>
<h4 id="一致性hash算法分片"><a href="#一致性hash算法分片" class="headerlink" title="一致性hash算法分片"></a>一致性hash算法分片</h4><blockquote>
<p>数据分布不均匀，<br>利用虚拟节点分布于hash环，通过hash算法将数据均匀分布在节点</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-murmur&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>orderId<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>murmur<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;murmur&quot;</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMurmurHash&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;seed&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 默认是0 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;virtualBucketTimes&quot;</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bucketMapPath&quot;</span>&gt;</span>E:\idea\Mycat-Server-Mycat-server-1675-release\src\main\resources<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="调增一致性hash算法分片"><a href="#调增一致性hash算法分片" class="headerlink" title="调增一致性hash算法分片"></a>调增一致性hash算法分片</h4><blockquote>
<p>数据分布均匀，效率高，消耗少，有分布式事务问题</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;jch&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>tenant_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>jump-consistent-hash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;jump-consistent-hash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByJumpConsistentHash&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;totalBuckets&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="myCat-全局表"><a href="#myCat-全局表" class="headerlink" title="myCat 全局表"></a>myCat 全局表</h4><blockquote>
<p>数据冗余</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;sys_xxx&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn140,dn141&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="MyCat-动态扩容"><a href="#MyCat-动态扩容" class="headerlink" title="MyCat 动态扩容"></a>MyCat 动态扩容</h4><p>1.新增 newSchema.xml 和 newRule.xml 并配置成扩容后的节点<br><img src="/image/2020-12-10_5fd1e973ebd30.png"></p>
<p>2.修改dataMigrate.sh文件<br>该文件类型是dos的，需要修改为unix类型<br>查看.sh文件类型：:set ff<br>修改.sh文件类型：:set ff=unix 回车</p>
<p>3.修改dataMigrate.sh中的配置<br>基本上修改一个即可：</p>
<blockquote>
<p>mysql bin路径<br>RUN_CMD=”$RUN_CMD -mysqlBin=/usr/bin”<br>这个是mysqldump文件的路径，<br>找该文件：find / -name mysqldump</p>
</blockquote>
<p>4.修改/conf/下migrateTables.properties配置文件，指定需要迁移的逻辑库和表</p>
<ol start="5">
<li>执行 ./dataMigrate.sh</li>
</ol>
<p>数据迁移后将newSchema.xml和 newRule.xml 替换schema.xml,rule.xml(整个过程可以在mycat 未开启的状态下迁移)</p>
<p>注意事项<br>1、jdk不能用openJdk，需要自己安装，配置环境变量<br>2、之前的老的schema.xml和rule.xml老配置不能动<br>3、新增迁移后的节点新配置newSchema.xml和newRule.xml<br>4、mycat bug migrateTables.properties中逻辑库的名称不能既有大些又有小写。<br>5、迁移类：DataMigrator</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/study/mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" data-id="cklhojuyb00030csx56bj33mu" data-title="分库分表" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mycat/" rel="tag">mycat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mycat读写分离" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/study/mycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:40:38.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/15/study/mycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">mycat读写分离</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="读写分离方案选型"><a href="#读写分离方案选型" class="headerlink" title="读写分离方案选型"></a>读写分离方案选型</h2><h3 id="Replication常用架构"><a href="#Replication常用架构" class="headerlink" title="Replication常用架构"></a>Replication常用架构</h3><h4 id="常规复制架构-Master-—-Slaves"><a href="#常规复制架构-Master-—-Slaves" class="headerlink" title="常规复制架构(Master — Slaves)"></a>常规复制架构(Master — Slaves)</h4><img src="/image/mycat读写分离1.png" width="80%">

<p>缺点：</p>
<ul>
<li>master不能停机，停机就不能接收写请求</li>
<li>slave过多会出现延迟</li>
</ul>
<p>由于master需要进行常规维护停机了，那么必须要把一个slave提成master，选哪一个是一个问题？<br>某一个slave提成master了，就存在当前master和之前的master数据不一致的情况，并且之前master并没有保存当前master节点的binlog文件和pos位置。</p>
<h4 id="Dual-Master-复制架构-Master-—-Master-Master"><a href="#Dual-Master-复制架构-Master-—-Master-Master" class="headerlink" title="Dual Master 复制架构(Master — Master) Master)"></a>Dual Master 复制架构(Master — Master) Master)</h4><img src="/image/mycat读写分离2.png" width="80%">

<p>可以配合一个第三方的工具，比如keepalived轻松做到IP的漂移，停机维护也不会影响写操作。</p>
<h4 id="级联复制架构-Master-—-Slaves-—-Slaves-…-…"><a href="#级联复制架构-Master-—-Slaves-—-Slaves-…-…" class="headerlink" title="级联复制架构(Master — Slaves — Slaves …) …)"></a>级联复制架构(Master — Slaves — Slaves …) …)</h4><img src="/image/mycat读写分离3.png" width="80%">

<p>如果读压力加大，就需要更多的slave来解决，但是如果slave的复制全部从master复制，势必会加大master的复制IO的压力，所以就出现了级联复制，减轻master压力。</p>
<h4 id="Dual-Master-与级联复制结合架构-Master-Master-Slaves"><a href="#Dual-Master-与级联复制结合架构-Master-Master-Slaves" class="headerlink" title="Dual Master 与级联复制结合架构(Master -Master - Slaves)"></a>Dual Master 与级联复制结合架构(Master -Master - Slaves)</h4><img src="/image/mycat读写分离4.png" width="80%">
这样解决了单点master的问题，解决了slave级联延迟的问题.

<h4 id="Replication机制的实现原理"><a href="#Replication机制的实现原理" class="headerlink" title="Replication机制的实现原理"></a>Replication机制的实现原理</h4><img src="/image/mycat读写分离5.png" width="80%">


<h3 id="mysql主从复制"><a href="#mysql主从复制" class="headerlink" title="mysql主从复制"></a>mysql主从复制</h3><h4 id="基于docker"><a href="#基于docker" class="headerlink" title="基于docker"></a>基于docker</h4><p>1.创建端口为3307的mysql容器：<br>docker run -p 3307:3306  –restart=always  –privileged=true –name mysql -v /home/mysql/docker-data/3307/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/3307/data/:/var/lib/mysql -v /home/mysql/docker-data/3307/logs/:/var/log/mysql -e MYSQL_ROOT_PASSWORD=”123456” -d mysql:5.7</p>
<p>master my.cnf配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// master配置</span><br><span class="line">server-id=1283307</span><br><span class="line">log-bin=mysql-bin //开启复制功能</span><br><span class="line">auto_increment_increment=2</span><br><span class="line">auto_increment_offset=1</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">binlog-do-db=mstest //要同步的mstest数据库,要同步多个数据库</span><br><span class="line">binlog-ignore-db=mysql //要忽略的数据库</span><br></pre></td></tr></table></figure>


<p>2.创建端口为3308的mysql容器：<br>docker run -p 3308:3306  –restart=always  –privileged=true –name mysql -v /home/mysql/docker-data/3308/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/3308/data/:/var/lib/mysql -v /home/mysql/docker-data/3308/logs/:/var/log/mysql -e MYSQL_ROOT_PASSWORD=”123456” -d mysql:5.7</p>
<p>slave my.cnf配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// slave配置</span><br><span class="line">server-id=1293308</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">auto-increment-increment=2</span><br><span class="line">auto-increment-offset=2</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">replicate-do-db = wang #需要同步的数据库</span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line">binlog-ignore-db = information_schema</span><br></pre></td></tr></table></figure>

<h5 id="1-在master-mysql添加权限"><a href="#1-在master-mysql添加权限" class="headerlink" title="1.在master mysql添加权限"></a>1.在master mysql添加权限</h5><p>GRANT REPLICATION SLAVE,FILE,REPLICATION CLIENT ON <em>.</em> TO ‘repluser’@’%’ IDENTIFIED BY ‘123456’;<br>FLUSH PRIVILEGES;</p>
<h5 id="2-在master上查看master的二进制日志"><a href="#2-在master上查看master的二进制日志" class="headerlink" title="2.在master上查看master的二进制日志"></a>2.在master上查看master的二进制日志</h5><img src="/image/mycat12.png" width="80%">
##### 3 在slave中设置master的信息
change master to master_host='192.168.231.128',
master_port=3307,master_user='repluser',master_password='123456',master_log_file='mysql-bin.000001',master_log_pos=154;
##### 4 开启slave，启动SQL和IO线程
start slave;
##### 效果：
master:新增数据
<img src="/image/mycat读写分离6.png" width="80%">
slave:同步数据
<img src="/image/mycat读写分离7.png" width="80%">



<h4 id="主从半同步复制："><a href="#主从半同步复制：" class="headerlink" title="主从半同步复制："></a>主从半同步复制：</h4><h5 id="加载lib，所有主从节点都要配置"><a href="#加载lib，所有主从节点都要配置" class="headerlink" title="加载lib，所有主从节点都要配置"></a>加载lib，所有主从节点都要配置</h5><p>主库：install plugin rpl_semi_sync_master soname ‘semisync_master.so’;<br>从库：install plugin rpl_semi_sync_slave soname ‘semisync_slave.so’;<br>可以一起装。建议一起装，因为会有主从切换的情景。</p>
<h5 id="启用半同步"><a href="#启用半同步" class="headerlink" title="启用半同步"></a>启用半同步</h5><p>先启用从库上的参数，最后启用主库的参数。<br>从库：set global rpl_semi_sync_slave_enabled = {0|1}; # 1：启用，0：禁止<br>主库：<br>set global rpl_semi_sync_master_enabled = {0|1}; # 1：启用，0：禁止</p>
<p>//设置msater等待slave应答时间（默认10秒），无应答会从半同步复制变成异步复制<br>set global rpl_semi_sync_master_timeout = 10000; # 单位为ms </p>
<h5 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h5><img src="/image/mycat读写分离8.png" width="80%">
wait_point: AFTER_SYNC :增强版半同步复制

<h3 id="mysql高可用"><a href="#mysql高可用" class="headerlink" title="mysql高可用"></a>mysql高可用</h3><img src="/image/mycat读写分离9.png" width="80%">
##### 配置haproxy

<ul>
<li><p>新建目录和用户<br>mkdir /etc/haproxy mkdir /var/lib/haproxy useradd -r haproxy</p>
</li>
<li><p>配置日志<br>vim /etc/rsyslog.conf<br>Provides TCP syslog reception #去掉下面两行注释，开启TCP监听<br>$ModLoad imudp<br>$UDPServerRun 514<br>local2.* /var/log/haproxy.log #添加日志</p>
</li>
<li><p>vi /etc/sysconfig/rsyslog<br>SYSLOGD_OPTIONS=””<br>改为SYSLOGD_OPTIONS=”-r -m 2 -c 2”</p>
</li>
<li><p>创建日志文件<br>touch /var/log/haproxy.log</p>
</li>
<li><p>启动日志<br>systemctl restart rsyslog.service</p>
</li>
<li><p>启动haproxy cd /usr/sbin/haproxy<br>./haproxy -f /etc/haproxy/haproxy.cfg</p>
</li>
<li><p>在两台数据库添加远程访问权限<br>GRANT ALL ON <em>.</em> TO ‘root’@’%’ IDENTIFIED BY ‘123456’;<br>FLUSH PRIVILEGES;</p>
</li>
<li><p>测试haproxy服务器能否连接到数据库服务器</p>
</li>
<li><p>安装mysql客户端<br>yum install -y mysql<br>mysql -uroot -p123456 -h 192.168.231.128<br>mysql -uroot -p123456 -h 192.168.231.129</p>
</li>
<li><p>在非haproxy服务器测试通过访问haproxy访问到mysql服务<br>mysql -uroot -p123456 -h 192.168.231.128 -P 3300</p>
</li>
<li><p>访问页面<a target="_blank" rel="noopener" href="http://192.168.231.128:1080/stats">http://192.168.231.128:1080/stats</a></p>
<img src="/image/mycat读写分离10.png" width="80%">
</li>
<li><p>keepalived源码安装<br>wget <a target="_blank" rel="noopener" href="http://www.keepalived.org/software/keepalived-1.3.5.tar.gz">http://www.keepalived.org/software/keepalived-1.3.5.tar.gz</a><br>tar -zxvf keepalived-1.3.5.tar.gz</p>
</li>
<li><p>安装openssl openssl-devel<br>yum -y install openssl openssl-devel<br>./configure –prefix=/usr/local/keepalived –sbindir=/usr/sbin/ –sysconfdir=/etc/ –<br>mandir=/usr/local/share/man/<br>make &amp;&amp; make install</p>
</li>
<li><p>修改配置<br>vi /etc/keepalived/keepalived.conf</p>
</li>
<li><p>给执行权限 # chmod +x /etc/keepalived/chk.sh</p>
</li>
<li><p>keepalived yum安装</p>
</li>
<li><p>预先安装好epel-release源<br>yum list installed|grep epel-release</p>
</li>
<li><p>查找可用安装的keepalived源<br>yum search keepalived</p>
</li>
<li><p>命令进行安装<br>yum install keepalived -y</p>
</li>
<li><p>启动keepalived服务<br>systemctl start keepalived</p>
</li>
<li><p>使用yum安装的会有一个默认配置文件模板</p>
</li>
<li><p>路径为/etc/keepalived/keepalived.conf<br>yum install ipvsadm -y</p>
</li>
</ul>
<p>mysql -h 192.168.67.140 -u root -p123456 -P 3307 -e “show status;” &gt;/dev/null 2&gt;&amp;1</p>
<blockquote>
<p>/dev/null 2&gt;&amp;1 输出”黑洞”<br>$? 上一个指令是否执行成功<br>0 成功1 失</p>
</blockquote>
<h3 id="MyCat配置："><a href="#MyCat配置：" class="headerlink" title="MyCat配置："></a>MyCat配置：</h3><h4 id="结构图如下："><a href="#结构图如下：" class="headerlink" title="结构图如下："></a>结构图如下：</h4><img src="/image/mycat读写分离11.png" width="80%">
##### 将MyCat配置到环境变量中
 vi /etc/profile
增加如下内容　　　　　　　　　
MYCAT_HOME=/usr/local/mycat
PATH=$MYCAT_HOME/bin:$PATH

<p>配置schema.xml：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat&#x3D;&quot;http:&#x2F;&#x2F;io.mycat&#x2F;&quot;&gt;</span><br><span class="line">    &lt;!-- 定义虚拟数据库名称 --&gt;</span><br><span class="line">    &lt;schema name&#x3D;&quot;mycat_mdr&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot; dataNode&#x3D;&quot;dn1&quot; &gt;</span><br><span class="line">        &lt;!-- 这里配置分库分表，因只做读写分离所以这里暂不配置 --&gt;</span><br><span class="line">    &lt;&#x2F;schema&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dataNode name&#x3D;&quot;dn1&quot; dataHost&#x3D;&quot;192.168.231.128&quot; database&#x3D;&quot;marvel_test&quot; &#x2F;&gt; </span><br><span class="line">    &lt;!-- 上述这里三个参数分别是定义dataNode的别名、数据库的IP或局域网服务器的别名在hosts中配置、数据库名 --&gt;</span><br><span class="line">    &lt;!-- 将balance设置为3表示开启读写分离 --&gt;</span><br><span class="line">    &lt;dataHost name&#x3D;&quot;localhost&quot; maxCon&#x3D;&quot;1000&quot; minCon&#x3D;&quot;10&quot; balance&#x3D;&quot;3&quot;</span><br><span class="line">              writeType&#x3D;&quot;0&quot; dbType&#x3D;&quot;mysql&quot; dbDriver&#x3D;&quot;native&quot; switchType&#x3D;&quot;1&quot;  slaveThreshold&#x3D;&quot;100&quot;&gt;</span><br><span class="line">        &lt;!-- 定时执行SQL保持心跳 --&gt;</span><br><span class="line">        &lt;heartbeat&gt;select user()&lt;&#x2F;heartbeat&gt;</span><br><span class="line">        &lt;!-- 添加写入库配置 --&gt;</span><br><span class="line">        &lt;writeHost host&#x3D;&quot;hostM1&quot; url&#x3D;&quot;192.168.231.128:3307&quot; user&#x3D;&quot;root&quot;</span><br><span class="line">                   password&#x3D;&quot;123456&quot;&gt;</span><br><span class="line">            &lt;!-- 添加只读库配置--&gt;</span><br><span class="line">            &lt;readHost host&#x3D;&quot;hostS1&quot; url&#x3D;&quot;192.168.231.129:3308&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;123456&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;writeHost&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dataHost&gt;</span><br><span class="line">&lt;&#x2F;mycat:schema&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/study/mycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" data-id="cklhojuye00060csx0utk7rpb" data-title="mycat读写分离" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mycat/" rel="tag">mycat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/RocketMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/study/RocketMQ/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:40:38.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/15/study/RocketMQ/">rocketMq学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="RokectMQ学习"><a href="#RokectMQ学习" class="headerlink" title="RokectMQ学习"></a>RokectMQ学习</h1><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>nameServer: Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步</p>
<p>消息：字节数组</p>
<p><strong>设计理念</strong>：</p>
<p><strong>基于主题</strong>，发布和订阅</p>
<p><strong>核心功能</strong>：消息发送，消息存储（持久化方式：磁盘），消息消费</p>
<p><strong>设计目标</strong>：</p>
<ul>
<li>顺序消息</li>
<li>消息过滤（客户端实现，服务端实现）</li>
<li>消息存储 从两个维度：消息堆积（顺序读写在一个文件，存储空间预警机制，过期文件删除机制）；存储性能</li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h4 id="nameserver"><a href="#nameserver" class="headerlink" title="nameserver"></a><strong>nameserver</strong></h4><p>相对来说，nameserver的稳定性非常高。原因有二:</p>
<ol>
<li>nameserver互相独立，彼此没有通信关系，单台nameserver挂掉，不影响其他nameserver，即使全部挂掉，也不影响业务系统使用，这点类似于dubbo的zookeeper。</li>
<li>nameserver不会有频繁的读写，所以性能开销非常小，稳定性很高。</li>
</ol>
<h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a><strong>broker</strong></h4><h5 id="1-与nameserver关系"><a href="#1-与nameserver关系" class="headerlink" title="1 与nameserver关系"></a><strong>1 与nameserver关系</strong></h5><p>单个broker和所有nameserver保持长连接</p>
<p><strong>心跳间隔</strong>：每隔30秒（<strong>此时间无法更改</strong>）向所有nameserver发送心跳，心跳包含了自身的topic配置信息。</p>
<p><strong>心跳超时</strong>：nameserver每隔10秒钟（<strong>此时间无法更改</strong>），扫描所有还存活的broker连接，若某个连接2分钟内（<strong>当前时间与最后更新时间差值超过2分钟，此时间无法更改</strong>）没有发送心跳数据，则断开连接。</p>
<p><strong>时机</strong>：broker挂掉；心跳超时导致nameserver主动关闭连接</p>
<p><strong>动作</strong>：一旦连接断开，nameserver会立即感知，更新topc与队列的对应关系，但不会通知生产者和消费者</p>
<p><strong>2 负载均衡</strong><br>一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。<br>如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。<br>topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。</p>
<p><strong>3 可用性</strong><br>由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。<br>这里有两个关键点：<br>一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。<br>消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。</p>
<p><strong>4 可靠性</strong><br>所有发往broker的消息，有同步刷盘和异步刷盘机制，总的来说，可靠性非常高<br>同步刷盘时，消息写入物理文件才会返回成功，因此非常可靠<br>异步刷盘时，只有机器宕机，才会产生消息丢失，broker挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p><strong>1 与nameserver关系</strong><br><strong>连接</strong><br>单个消费者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，消费者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。<br><strong>心跳</strong><br>与nameserver没有心跳<br><strong>轮询时间</strong><br>默认情况下，消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。该时间由DefaultMQPushConsumer的pollNameServerInteval参数决定，可手动配置。</p>
<p><strong>2 与broker关系</strong><br><strong>连接</strong>：<br>单个消费者和该消费者关联的所有broker保持长连接。<br><strong>心跳</strong>：<br>默认情况下，消费者每隔30秒向所有broker发送心跳，该时间由DefaultMQPushConsumer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费<br><strong>断开</strong>：<br>时机：消费者挂掉；心跳超时导致broker主动关闭连接<br>动作：一旦连接断开，broker会立即感知到，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费</p>
<p><strong>3 消费机制</strong><br><strong>本地队列</strong><br>消费者不间断的从broker拉取消息，消息拉取到本地队列，然后本地消费线程消费本地消息队列，只是一个异步过程，拉取线程不会等待本地消费线程，这种模式实时性非常高。对消费者对本地队列有一个保护，因此本地消息队列不能无限大，否则可能会占用大量内存，本地队列大小由DefaultMQPushConsumer的pullThresholdForQueue属性控制，默认1000，可手动设置。</p>
<p><strong>4 如果一个topic在某broker上有3个队列，一个消费者消费这3个队列，那么该消费者和这个broker有几个连接？</strong><br>一个连接，消费单位与队列相关，消费连接只跟broker相关，事实上，消费者将所有队列的消息拉取任务放到本地的队列，挨个拉取，拉取完毕后，又将拉取任务放到队尾，然后执行下一个拉取任务</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p><strong>1 与nameserver关系</strong><br><strong>连接</strong><br>单个生产者者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，生产者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。<br><strong>轮询时间</strong><br>默认情况下，生产者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，生产者最多要30秒才能感知，在此期间，发往该broker的消息发送失败。该时间由DefaultMQProducer的pollNameServerInteval参数决定，可手动配置。<br><strong>心跳</strong><br>与nameserver没有心跳</p>
<p><strong>2 与broker关系</strong><br><strong>连接</strong><br>单个生产者和该生产者关联的所有broker保持长连接。<br><strong>心跳</strong><br>默认情况下，生产者每隔30秒向所有broker发送心跳，该时间由DefaultMQProducer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接。<br><strong>连接断开</strong><br>移除broker上的生产者信息</p>
<p><strong>3 负载均衡</strong><br>生产者时间没有关系，每个生产者向队列轮流发送消息</p>
<p><strong>其他参数概念</strong>：</p>
<p><strong>Topic</strong>:一级消息主题（类型）（例如服装订单消息，支付消息）</p>
<p><strong>Tags</strong>:二级消息类型 （具体分类，例如男装，女装）</p>
<p>什么时候用topic? 什么时候用tag?</p>
<ul>
<li>消息类型是否一致？不同，用topic区分</li>
<li>业务是否相关联，没有关系用topic区分，有关系用tag区分</li>
<li>消息的优先级是否一致，不同优先级用不同topic区分</li>
<li>消息量是否相当 不同用topic区分</li>
</ul>
<p><strong>Message key</strong>:业务层面唯一标识，rocket 会建立key与消息的映射（hash索引）适用解决幂等问题</p>
<p><strong>MessageID</strong>:rocketMq全局唯一标识（内部机制id，机器ip，消息偏移量）</p>
<p>三种发送方式：</p>
<ul>
<li>单向发送 ：最快，数据有可能丢失  适用日志收集</li>
<li>同步可靠发送 ：快 数据不丢失 消息量较小  通知，短信</li>
<li>异步可靠发送  ： 视频上传等</li>
</ul>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><p><strong>群组消费</strong>：一个队列只能被一个消费者消费</p>
<p><strong>广播消费</strong>：每个消费者都消费所有消息</p>
<h4 id="消费方式："><a href="#消费方式：" class="headerlink" title="消费方式："></a>消费方式：</h4><p><strong>拉模式</strong>：需要自己处理queue，自己保存偏移量，灵活，代码多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; OFFSE_TABLE = <span class="keyword">new</span> HashMap&lt;MessageQueue, Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">//拉模式</span></span><br><span class="line">        DefaultMQPullConsumer consumer = <span class="keyword">new</span> DefaultMQPullConsumer(<span class="string">&quot;pullconsumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.0.128:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//consumer.setBrokerSuspendMaxTimeMillis(1000);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ms:&quot;</span>+consumer.getBrokerSuspendMaxTimeMillis());</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取MessageQueues并遍历（一个Topic包括多个MessageQueue  默认4个）</span></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">&quot;TopicTest&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;queueID:&quot;</span>+ mq.getQueueId());</span><br><span class="line">            <span class="comment">//获取偏移量</span></span><br><span class="line">            <span class="keyword">long</span> Offset = consumer.fetchConsumeOffset(mq,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;Consume from the queue: %s%n&quot;</span>, mq);</span><br><span class="line">            SINGLE_MQ:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//拉模式，必须无限循环</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PullResult pullResult =</span><br><span class="line">                        consumer.pullBlockIfNotFound(mq, <span class="keyword">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>,pullResult);</span><br><span class="line">                    <span class="comment">//2.维护Offsetstore（这里存入一个Map）</span></span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3.根据不同的消息状态做不同的处理</span></span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND: <span class="comment">//获取到消息</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pullResult.getMsgFoundList().size();i++) &#123;</span><br><span class="line">                                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, <span class="keyword">new</span> String(pullResult.getMsgFoundList().get(i).getBody()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_MATCHED_MSG: <span class="comment">//没有匹配的消息</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_NEW_MSG:  <span class="comment">//没有新消息</span></span><br><span class="line">                            <span class="keyword">break</span> SINGLE_MQ;</span><br><span class="line">                        <span class="keyword">case</span> OFFSET_ILLEGAL: <span class="comment">//非法偏移量</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        Long offset = OFFSE_TABLE.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        OFFSE_TABLE.put(mq, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>推模式</strong>: 本质上是用拉模式封装的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;192.168.0.128:9876&quot;</span>);</span><br><span class="line">    consumer.setAllocateMessageQueueStrategy(<span class="keyword">new</span> AllocateMessageQueueAveragely());</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);<span class="comment">//每次从最后一次消费的地址</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;queueID:%d:%s:Messages:%s %n&quot;</span>,  msgs.get(<span class="number">0</span>).getQueueId(),Thread.currentThread().getName(), <span class="keyword">new</span> String(msgs.get(<span class="number">0</span>).getBody()));</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;ConsumerPartOrder Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h4><ul>
<li>验证消息</li>
<li>查找路由</li>
<li>消息发送</li>
</ul>
<h4 id="消息队列负载"><a href="#消息队列负载" class="headerlink" title="消息队列负载"></a>消息队列负载</h4><ul>
<li>平均分配 AllocateMessageQueueAveragely  （默认情况使用）</li>
<li>平均轮询分配 AllocateMessageQueueAveragelyByCircle</li>
<li>一致性hash</li>
<li>根据配置</li>
<li>根据broker部署的机房名</li>
</ul>
<h4 id="重新分布机制"><a href="#重新分布机制" class="headerlink" title="重新分布机制"></a>重新分布机制</h4><p>RebalanceService 每隔20s进行一次队列负载</p>
<h4 id="消息确认（ACK）"><a href="#消息确认（ACK）" class="headerlink" title="消息确认（ACK）"></a>消息确认（ACK）</h4><p>确保消费者成功 ConsumeConcurrentlyStatus</p>
<p>每次去消费的时候，记录消费进度，只会把一批（最小的offset进行确认存储），不去一条条提交偏移量</p>
<p>问题：会出现重复消费，在业务中进行幂等处理。</p>
<h4 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h4><p>首先进入%RETRY%consumerGroup</p>
<p>重新发送到原来的队列（延迟10s）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMaxReconsumeTimes(<span class="number">3</span>);<span class="comment">//重试次数,默认15次</span></span><br></pre></td></tr></table></figure>

<p>超过重试次数，进入DLQ队列</p>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序的监听事件</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:Messages:%s %n&quot;</span>, Thread.currentThread().getName(), <span class="keyword">new</span> String(msgs.get(<span class="number">0</span>).getBody()));</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="RocketMq事务消息"><a href="#RocketMq事务消息" class="headerlink" title="RocketMq事务消息"></a>RocketMq事务消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">    TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">    <span class="comment">//支持事务的生产者 TransactionMQProducer</span></span><br><span class="line">    TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;transaction_producer&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;192.168.0.128:9876&quot;</span>);</span><br><span class="line">    <span class="comment">//设置用于事务消息的处理线程池</span></span><br><span class="line">    ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    producer.setExecutorService(executorService);</span><br><span class="line">    <span class="comment">//设置事务监听器，监听器实现接口org.apache.rocketmq.client.producer.TransactionListener</span></span><br><span class="line">    <span class="comment">//监听器中实现需要处理的交易业务逻辑的处理，以及MQ Broker中未确认的事务与业务的确认逻辑</span></span><br><span class="line">    producer.setTransactionListener(transactionListener);</span><br><span class="line">    producer.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成不同的Tag，用于模拟不同的处理场景</span></span><br><span class="line">    String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//10条消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//组装产生消息</span></span><br><span class="line">            Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">&quot;TopicTransaction&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                            (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">//以事务发送消息，并在事务消息被成功预写入到RocketMQ中后，执行用户定义的交易逻辑，</span></span><br><span class="line">            <span class="comment">//交易逻辑执行成功后，再实现实现业务消息的提交逻辑</span></span><br><span class="line">            SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;transaction_producer&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;192.168.0.128:9876&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTransaction&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置自动提交</span></span><br><span class="line">            context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到消息开始消费：&quot;</span>+msg + <span class="string">&quot; , content : &quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟业务处理</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//返回处理失败，该消息后续可以继续被消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回处理成功，该消息就不会再次投递过来了</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;consumer start ! &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使用transactionId</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 执行事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 执行本地事务开始</span></span><br><span class="line">        <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行本地事务...&quot;</span>+value);</span><br><span class="line">        <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">//LocalTransactionState.UNKNOW表示未知的事件，需要RocketMQ进一步服务业务进行确认该交易的处理</span></span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE; <span class="comment">//这条消息抛弃了（账户余额不足 1W）</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 执行本地事务结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法用于RocketMQ与业务确认未提交事务的消息的状态（一分钟执行一次）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务回查-----UNKNOW-----------&quot;</span>);</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        <span class="comment">//业务处理（1分钟）</span></span><br><span class="line">        <span class="keyword">int</span> mod = msg.getTransactionId().hashCode() % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mod) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/study/RocketMQ/" data-id="cklhojuym000t0csx7srahhdm" data-title="rocketMq学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/rabbitMq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/study/rabbitMq/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:40:38.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/15/study/rabbitMq/">rabbitMq学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="rabbitMq："><a href="#rabbitMq：" class="headerlink" title="rabbitMq："></a>rabbitMq：</h2><blockquote>
<p>优点：解耦，异步，缓冲，伸缩性，扩展性</p>
<p>与Rpc的区别：Rpc同步，mq异步        </p>
</blockquote>
<h3 id="rabbitMq概念："><a href="#rabbitMq概念：" class="headerlink" title="rabbitMq概念："></a>rabbitMq概念：</h3><ul>
<li>Broker:标识消息队列服务器实体。</li>
<li>Virtual Host：虚拟主机， 每个vhost本质上就是一个mini版的RabbitMQ服务器。</li>
<li>Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li>
<li>Queue:消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>
<li>Banding：绑定，用于消息队列和交换机之间的关联，一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li>
<li>Channel：信道，多路复用连接中的一条独立的双向数据流通道</li>
</ul>
<h2 id="Exchange分发策略"><a href="#Exchange分发策略" class="headerlink" title="Exchange分发策略"></a>Exchange分发策略</h2><ul>
<li><p>direct:消息中的路由键如果和Binding中的binding key一致，交换器就将消息发到对应的队列中。路由键                                  与队列名完全匹配。(完全匹配)</p>
</li>
<li><p>fanout(广播):每个发到fanout类型交换器的消息都会分到所有绑定的队列上去</p>
</li>
<li><p>topic:必须由（.）分割的单词列表。比如apple.banana.orange</p>
<blockquote>
<p>可以代替一个单词。</p>
<p> #可以代替零个或多个单词。</p>
</blockquote>
</li>
</ul>
<img src="/image/截图.png" width="70%">

<h1 id="交换器（原生客户端）"><a href="#交换器（原生客户端）" class="headerlink" title="交换器（原生客户端）"></a>交换器（原生客户端）</h1><h3 id="Direct交换器："><a href="#Direct交换器：" class="headerlink" title="Direct交换器："></a>Direct交换器：</h3><h4 id="product"><a href="#product" class="headerlink" title="product:"></a>product:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接、连接到RabbitMQ</span></span><br><span class="line">ConnectionFactory connectionFactory= <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置下连接工厂的连接地址(使用默认端口5672)</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection =connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建信道</span></span><br><span class="line">Channel channel =connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_logs&quot;</span>,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明队列（放在消费者中去做）</span></span><br><span class="line"><span class="comment">//申明路由键\消息体</span></span><br><span class="line">String[] routeKeys =&#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    String routeKey = routeKeys[i%<span class="number">3</span>];</span><br><span class="line">    String msg = <span class="string">&quot;Hello,RabbitMQ&quot;</span>+(i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发布消息 </span></span><br><span class="line"> channel.basicPublish(<span class="string">&quot;direct_logs&quot;</span>,routeKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;Sent:&quot;</span>+routeKey+<span class="string">&quot;:&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer:"></a>consumer:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接、连接到RabbitMQ</span></span><br><span class="line">ConnectionFactory connectionFactory= <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置下连接工厂的连接地址(使用默认端口5672)</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection =connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建信道</span></span><br><span class="line">Channel channel =connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_logs&quot;</span>,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明队列（放在消费者中去做）</span></span><br><span class="line">String queueName=<span class="string">&quot;queue-a&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定：将队列(queuq-a)与交换器通过 路由键 绑定(aaa)</span></span><br><span class="line">String routeKey =<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">channel.queueBind(queueName,DirectProducer.EXCHANGE_NAME,routeKey);</span><br><span class="line">System.out.println(<span class="string">&quot;waiting for message ......&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明一个消费者</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer  = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String s, Envelope envelope, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()+<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消息者正是开始在指定队列上消费。(queue-a)</span></span><br><span class="line"><span class="comment">//TODO 这里第二个参数是自动确认参数，如果是true则是自动确认</span></span><br><span class="line">channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure>

<h3 id="fanout-交换器"><a href="#fanout-交换器" class="headerlink" title="fanout 交换器"></a>fanout 交换器</h3><p>routeKey无论设置为任何键，消息都会发到每一个队列</p>
<h3 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h3><blockquote>
<p> *与#的区别：如果我们发送的路由键变成king.kafka.A,那么队列中如果绑定了king.* 不能匹配队列中如果绑定了king.# 能够匹配</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 根据需求绑定不同routeKey</span></span><br><span class="line">channel.queueBind(queueName,TopicProducer.EXCHANGE_NAME, <span class="string">&quot;king.#&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="消息发布和消费的权衡"><a href="#消息发布和消费的权衡" class="headerlink" title="消息发布和消费的权衡"></a>消息发布和消费的权衡</h1><h2 id="发布时的权衡："><a href="#发布时的权衡：" class="headerlink" title="发布时的权衡："></a>发布时的权衡：</h2><p>在RabbitMQ 中，有不同的投递机制（生产者），但是每一种机制都对性能有一定的影响。一般来讲速度快的可靠性低，可靠性好的性能差，具体怎么使用需要根据你的应用程序来定，所以说没有最好的方式，只有最合适的方式。只有把你的项目和技术相结合，才能找到适合你的平衡。</p>
<img src="/image/WechatIMG8525.png" width="100%">

<h4 id="1-无保障："><a href="#1-无保障：" class="headerlink" title="1.无保障："></a>1.无保障：</h4><p><em>在演示各种交换器中使用的就是无保障的方式，通过basicPublish 发布你的消息并使用正确的交换器和路由信息，你的消息会被接收并发送到合适的队列中。但是如果有网络问题，或者消息不可路由，或者RabbitMQ 自身有问题的话，这种方式就有风险。所以无保证的消息发送一般情况下不推荐。</em></p>
<h4 id="2-失败确认"><a href="#2-失败确认" class="headerlink" title="2.失败确认"></a>2.失败确认</h4><p><em>在发送消息时设置mandatory 标志，告诉RabbitMQ，如果消息不可路由，应该将消息返回给发送者，并通知失败。可以这样认为，开启mandatory是开启故障检测模式。</em></p>
<blockquote>
<p>注意：它只会让RabbitMQ 向你通知失败，而不会通知成功。如果消息正确路由到队列，则发布者不会受到任何通知。带来的问题是无法确保发布消息一定是成功的，因为通知失败的消息可能会丢失。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//失败通知 回调</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replycode, String replyText, String exchange, String routeKey, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回的replycode:&quot;</span>+replycode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//TODO 第三个参数mandatory设置为true,开启故障检测模式 </span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,routekey,<span class="keyword">true</span>,<span class="keyword">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>

<h4 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h4><p><em>事务的实现主要是对信道（Channel）的设置，主要的方法有三个：</em></p>
<ol>
<li><p>channel.txSelect()声明启动事务模式；</p>
</li>
<li><p>channel.txComment()提交事务；</p>
</li>
<li><p>channel.txRollback()回滚事务；</p>
</li>
</ol>
<p><em>在发送消息之前，需要声明channel 为事务模式，提交或者回滚事务即可。开启事务后，客户端和RabbitMQ 之间的通讯交互流程：</em></p>
<ul>
<li><p>客户端发送给服务器Tx.Select(开启事务模式)</p>
</li>
<li><p>服务器端返回Tx.Select-Ok（开启事务模式ok）</p>
</li>
<li><p>推送消息</p>
</li>
<li><p>客户端发送给事务提交Tx.Commit</p>
</li>
<li><p> 服务器端返回Tx.Commit-Ok</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入事务</span></span><br><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        String routekey = routekeys[i%<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 发送的消息</span></span><br><span class="line">        String message = <span class="string">&quot;Hello World_&quot;</span>+(i+<span class="number">1</span>)</span><br><span class="line">                +(<span class="string">&quot;_&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routekey, <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: [&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事务提交</span></span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="comment">//事务回滚</span></span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么，既然已经有事务了，为何还要使用发送方确认模式呢，原因是因为事务的性能是非常差的。根据相关资料，事务会降低2~10 倍的性能。</p>
</blockquote>
<h4 id="4-发送发确认模式："><a href="#4-发送发确认模式：" class="headerlink" title="4.发送发确认模式："></a>4.发送发确认模式：</h4><p><em>基于事务的性能问题，RabbitMQ 团队为我们拿出了更好的方案，即采用发送方确认模式，该模式比事务更轻量，性能影响几乎可以忽略不计。原理：生产者将信道设置成confirm 模式，一旦信道进入confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1 开始)，由这个id 在生产者和RabbitMQ 之间进行消息的确认。不可路由的消息，当交换器发现，消息不能路由到任何队列，会进行确认操作，表示收到了消息。如果发送方设置了mandatory 模式,则会先调用addReturnListener 监听器。</em></p>
<p><em>可路由的消息，要等到消息被投递到所有匹配的队列之后，broker 会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中delivery-tag 域包含了确认消息的序列号。</em></p>
<p><em>confirm 模式最大的好处在于他可以是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack 消息，生产者应用程序同样可以在回调方法中处理该nack 消息决定下一步的处理。</em></p>
<h5 id="Confirm-的三种实现方式："><a href="#Confirm-的三种实现方式：" class="headerlink" title="Confirm 的三种实现方式："></a>Confirm 的三种实现方式：</h5><ul>
<li>方式一：channel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//确认是否成功(true成功)</span></span><br><span class="line"><span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;send success&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;send failure&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：channel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException 异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式（批量确认）</span></span><br><span class="line">channel.waitForConfirmsOrDie();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方式三：channel.addConfirmListener()异步监听发送方确认模式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO启用发送者确认模式 </span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//TODO添加发送者确认监听器</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">    <span class="comment">//TODO 成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;     System.out.println(<span class="string">&quot;send_ACK:&quot;</span>+deliveryTag+<span class="string">&quot;,multiple:&quot;</span>+multiple);&#125;</span><br><span class="line">    <span class="comment">//TODO 失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Erro----send_NACK:&quot;</span>+deliveryTag+<span class="string">&quot;,multiple:&quot;</span>+multiple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-备用交换器"><a href="#5-备用交换器" class="headerlink" title="5.备用交换器"></a>5.备用交换器</h4><p><em>在第一次声明交换器时被指定，用来提供一种预先存在的交换器，如果主交换器无法路由消息，那么消息将被路由到这个新的备用交换器。使用备用交换器，向往常一样，声明Queue 和备用交换器，把Queue 绑定到备用交换器上。然后在声明主交换器时，通过交换器的参数，alternate-exchange,，将备用交换器设置给主交换器。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明备用交换器</span></span><br><span class="line">Map&lt;String,Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">argsMap.put(<span class="string">&quot;alternate-exchange&quot;</span>,<span class="string">&quot;ae&quot;</span>);</span><br><span class="line"><span class="comment">//主交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;main-exchange&quot;</span>,<span class="string">&quot;direct&quot;</span>,</span><br><span class="line">        <span class="keyword">false</span>,<span class="keyword">false</span>,argsMap);</span><br><span class="line"><span class="comment">//备用交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;ae&quot;</span>,BuiltinExchangeType.FANOUT,</span><br><span class="line">        <span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="消息的消费权衡"><a href="#消息的消费权衡" class="headerlink" title="消息的消费权衡"></a>消息的消费权衡</h2><img src="/image/WechatIMG8528.png" width="80%">

<h3 id="消息的获取方式"><a href="#消息的获取方式" class="headerlink" title="消息的获取方式"></a>消息的获取方式</h3><h4 id="拉取Get"><a href="#拉取Get" class="headerlink" title="拉取Get"></a>拉取Get</h4><p>_属于一种轮询模型，发送一次get 请求，获得一个消息。如果此时RabbitMQ 中没有消息，会获得一个表示空的回复。总的来说，这种方式性能比较差，很明显，每获得一条消息，都要和RabbitMQ 进行网络通信发出请求。而且对RabbitMQ 来说，RabbitMQ 无法进行任何优化，因为它永远不知道应用程序何时会发出请求。具体使用，参见代码native 模块包cn.enjoyedu.consumer_balance.GetMessage 中。对我们实现者来说，要在一个循环里，不断去服务器get 消息。_</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 无限循环拉取</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//拉一条，自动确认的(rabbit 认为这条消息消费 -- 从队列中删除)</span></span><br><span class="line">    GetResponse getResponse = channel.basicGet(queueName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>!=getResponse)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;received[&quot;</span></span><br><span class="line">                +getResponse.getEnvelope().getRoutingKey()+<span class="string">&quot;]&quot;</span></span><br><span class="line">                +<span class="keyword">new</span> String(getResponse.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确认(自动、手动)</span></span><br><span class="line">    channel.basicAck(<span class="number">0</span>,<span class="keyword">true</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="推送Consume"><a href="#推送Consume" class="headerlink" title="推送Consume"></a>推送Consume</h4><p><em>属于一种推送模型。注册一个消费者后，RabbitMQ 会在消息可用时，自动将消息进行推送给消费者。</em></p>
<h4 id="消息的应答"><a href="#消息的应答" class="headerlink" title="消息的应答"></a>消息的应答</h4><p><em>前面说过，消费者收到的每一条消息都必须进行确认。消息确认后，RabbitMQ 才会从队列删除这条消息，RabbitMQ 不会为未确认的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是<strong>消费该消息的消费者连接是否已经断开</strong>。这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</em></p>
<h4 id="自动确认"><a href="#自动确认" class="headerlink" title="自动确认"></a>自动确认</h4><p><em>消费者在声明队列时，可以指定autoAck 参数，当autoAck=true 时，一旦消费者接收到了消息，就视为自动确认了消息。如果消费者在处理消息的过程中，出了错，就没有什么办法重新处理这条消息，所以我们很多时候，需要在消息处理成功后，再确认消息，这就需要手动确认。</em></p>
<h4 id="手动确认"><a href="#手动确认" class="headerlink" title="手动确认"></a>手动确认</h4><p>​        <em>当autoAck=false 时，RabbitMQ 会等待消费者显式发回ack 信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ 会在队列中消息被消费后立即删除它。</em>    </p>
<p>​        <em>采用消息确认机制后，只要令autoAck=false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ 会一直持有消息直到消费者显式调用basicAck 为止。</em></p>
<p>​        <em>当autoAck=false 时，对于RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者ack 信号的消息。如果服务器端一直没有收到消费者的ack 信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*声明了一个消费者*/</span></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params"> Envelope envelope,AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);                   System.out.println(<span class="string">&quot;Received&quot;</span>+message);</span><br><span class="line">                    <span class="comment">//确认</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//拒绝</span></span><br><span class="line"><span class="comment">//Reject方式拒绝，第二个参数决定是否重新投递</span></span><br><span class="line">channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*消费者正式开始在指定队列上消费消息*/</span></span><br><span class="line">        <span class="comment">//TODO 这里第二个参数是自动确认参数，如果是false则是手动确认</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">false</span>,consumer);</span><br></pre></td></tr></table></figure>

<h4 id="QoS-预取模式"><a href="#QoS-预取模式" class="headerlink" title="QoS 预取模式"></a>QoS 预取模式</h4><p><em>在确认消息被接收之前，消费者可以预先要求接收一定数量的消息，在处理完一定数量的消息后，批量进行确认。如果消费者应用程序在确认消息之前崩溃，则所有未确认的消息将被重新发送给其他消费者。所以这里存在着一定程度上的可靠性风险。这种机制一方面可以实现限速（将消息暂存到RabbitMQ 内存中）的作用，一方面可以保证消息确认质量（比如确认了但是处理有异常的情况）。</em></p>
<blockquote>
<p>注意：消费确认模式必须是非自动ACK 机制（这个是使用baseQos 的前提条件，否则会Qos 不生效），然后设置basicQos 的值；另外，还可以基于consume 和channel 的粒度进行设置（global）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量确认 -----消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchAckConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计数，第多少条</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> meesageCount =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchAckConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消费者启动了......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">      Envelope envelope,AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//把消息体拉出来</span></span><br><span class="line">        String message = <span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> System.out.println(message);</span><br><span class="line">        meesageCount++;</span><br><span class="line">        <span class="comment">//批量确认 50一批</span></span><br><span class="line">        <span class="keyword">if</span>(meesageCount %<span class="number">50</span> ==<span class="number">0</span>)&#123;        <span class="keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;批量消息费进行消息的确认------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果是最后一条消息，则把剩余的消息都进行确认</span></span><br><span class="line">       <span class="keyword">if</span>(message.equals(<span class="string">&quot;stop&quot;</span>))&#123;         <span class="keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;批量消费者进行最后业务消息的确认---------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息的拒绝"><a href="#消息的拒绝" class="headerlink" title="消息的拒绝"></a>消息的拒绝</h2><blockquote>
<p>Reject 和 N a c k  </p>
</blockquote>
<p>​        消息确认可以让RabbitMQ 知道消费者已经接受并处理完消息。但是如果消息本身或者消息的处理过程出现问题怎么办？需要一种机制，通知RabbitMQ，这个消息，我无法处理，请让别的消费者处理。这里就有两种机制，Reject 和Nack。Reject 在拒绝消息时，可以使用requeue 标识，告诉RabbitMQ 是否需要重新发送给别的消费者。如果是false 则不重新发送，一般这个消息就会被RabbitMQ 丢弃。Reject 一次只能拒绝一条消息。如果是true 则消息发生了重新投递。</p>
<p>​        Nack 跟Reject 类似，只是它可以一次性拒绝多个消息。也可以使用requeue 标识，这是RabbitMQ 对AMQP 规范的一个扩展。具体使用，当requeue参数设置为true 时，消息发生了重新投递。当requeue 参数设置为false 时，消息丢失了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reject方式拒绝，第二个参数决定是否重新投递</span></span><br><span class="line">channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">true</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//Nack方式拒绝，第二个参数决定是否批量,第三参数是否重新投递</span></span><br><span class="line">channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="死信交换器（DLX）"><a href="#死信交换器（DLX）" class="headerlink" title="死信交换器（DLX）"></a>死信交换器（DLX）</h2><blockquote>
<p>1.过期消息</p>
<p>2.消息队列达到最大长度，最开始的投递的消息</p>
<p>3.拒绝且requeue = false的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定死信交换器</span></span><br><span class="line">channel.exchageDeclare(DlxProducer.EXCHAGE_NAME, BuiltinExchageType.TOPIC);</span><br><span class="line"><span class="comment">//申明队列</span></span><br><span class="line">String queueName = <span class="string">&quot;dlx_make&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchage&quot;</span>, <span class="string">&quot;死信交换器名称&quot;</span>);</span><br><span class="line"><span class="comment">//TODO 死信路由键会替换原来路由键</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,args);</span><br><span class="line"><span class="comment">//将队列和交换器通过路由键绑定</span></span><br><span class="line">channel.queueBind(queueName,DlxProducer.EXCHAGE_NAME, <span class="string">&quot;#&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="死信交换器和备用交换器的区别"><a href="#死信交换器和备用交换器的区别" class="headerlink" title="死信交换器和备用交换器的区别"></a><strong>死信交换器和备用交换器的区别</strong></h4><blockquote>
<p>备用交换器是备胎：没有队列要它的时候只能选择备用交换器。死信交换器是老实人：消息已经被消费者玩过一遍，消费者没有消费，只能被死信交换器接收。</p>
</blockquote>
<h3 id="控制队列"><a href="#控制队列" class="headerlink" title="控制队列"></a>控制队列</h3><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><p><em>临时队列对应的是没有持久化的队列，也就是如果RabbitMQ 服务器重启，那么这些队列就不会存在，所以我们称之为临时队列。</em></p>
<h4 id="自动删除队列"><a href="#自动删除队列" class="headerlink" title="自动删除队列"></a>自动删除队列</h4><p><em>自动删除队列和普通队列在使用上没有什么区别，唯一的区别是，当消费者断开连接时，队列将会被删除。自动删除队列允许的消费者没有限制，也就是说当这个队列上最后一个消费者断开连接才会执行删除。</em></p>
<blockquote>
<p>自动删除队列只需要在声明队列时，设置属性auto-delete 标识为true 即可。系统声明的随机队列，缺省就是自动删除的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四个参数</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="单消费者队列"><a href="#单消费者队列" class="headerlink" title="单消费者队列"></a>单消费者队列</h4><p><em>普通队列允许的消费者没有限制，多个消费者绑定到多个队列时，RabbitMQ 会采用轮询进行投递。如果需要消费者独占队列，在队列创建的时候，设定属性exclusive 为true。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自动过期队列"><a href="#自动过期队列" class="headerlink" title="自动过期队列"></a>自动过期队列</h4><p><em>指队列在超过一定时间没使用，会被从RabbitMQ 中被删除。</em></p>
<p><em>什么是没使用？1.一定时间内没有Get 操作发生。2.没有Consumer 连接在队列上。特别的：就算一直有消息进入队列，也不算队列在被使用。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO /*自动过期队列--参数需要Map传递*/</span></span><br><span class="line">String queueName = <span class="string">&quot;setQueue&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-expires&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//10秒被删除</span></span><br><span class="line"><span class="comment">//TODO 队列的各种参数</span></span><br><span class="line"><span class="comment">/*加入队列的各种参数*/</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,arguments);</span><br></pre></td></tr></table></figure>

<h4 id="永久队列"><a href="#永久队列" class="headerlink" title="永久队列"></a>永久队列</h4><p><em>持久化队列和非持久化队列的区别是，持久化队列会被保存在磁盘中，固定并持久的存储，当Rabbit 服务重启后，该队列会保持原来的状态在RabbitMQ中被管理，而非持久化队列不会被保存在磁盘中，Rabbit 服务重启后队列就会消失。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将属性durable 设置为“true”，</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="队列级别消息过期"><a href="#队列级别消息过期" class="headerlink" title="队列级别消息过期"></a>队列级别消息过期</h4><p><em>就是为每个队列设置消息的超时时间。只要给队列设置x-message-ttl 参数，就设定了该队列所有消息的存活时间，时间单位是毫秒。如果声明队列时指定了死信交换器，则过期消息会成为死信消息。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO /*自动过期队列--参数需要Map传递*/</span></span><br><span class="line">String queueName = <span class="string">&quot;setQueue&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-expires&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//10秒被删除</span></span><br><span class="line"><span class="comment">//设定该队列消息存活时间，时间单位毫秒</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//消息10秒被删除</span></span><br><span class="line"><span class="comment">//TODO 队列的各种参数</span></span><br><span class="line"><span class="comment">/*加入队列的各种参数*/</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,arguments);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对队列中消息的条数进行限制x-max-length</p>
</li>
<li><p>对队列中消息的总量进行限制x-max-length-bytes</p>
</li>
</ul>
<h3 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h3><p><em>默认情况下，队列和交换器在服务器重启后都会消失，消息当然也是。将队列和交换器的durable 属性设为true，缺省为false，但是消息要持久化还不够，还需要将消息在发布前，将投递模式设置为2。消息要持久化，必须要有持久化的队列、交换器和投递模式都为2。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 创建持久化交换器 durable=true</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;direct&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//TODO 发布持久化的消息(delivery-mode=2)</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,routekey,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        msg.getBytes());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 声明一个持久化队列(durable=true)</span></span><br><span class="line">String queueName = <span class="string">&quot;msgdurable&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,</span><br><span class="line">        <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Request-Response-模式"><a href="#Request-Response-模式" class="headerlink" title="Request-Response 模式"></a>Request-Response 模式</h3><p>​        <em>我们前面的学习模式中都是一方负责发送消息而另外一方负责处理。而我们实际中的很多应用相当于一种一应一答的过程，需要双方都能给对方发送消息。于是请求-应答的这种通信方式也很重要。它也应用的很普遍。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 响应QueueName ，消费者将会把要返回的信息发送到该Queue</span></span><br><span class="line">String responseQueue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//TODO 消息的唯一id</span></span><br><span class="line">String msgId = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//TODO 设置消息中的应答属性</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">  <span class="comment">//replyTO构建回复消息的私有响应队列</span></span><br><span class="line">        .replyTo(responseQueue)</span><br><span class="line">        .messageId(msgId)</span><br><span class="line">        .build();</span><br><span class="line"> <span class="comment">/*声明了一个消费者*/</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()</span><br><span class="line">                        +<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//TODO 消费者应答队列上的消息</span></span><br><span class="line">channel.basicConsume(responseQueue,<span class="keyword">true</span>,consumer);</span><br><span class="line"> String msg = <span class="string">&quot;Hello,RabbitMq&quot;</span>;</span><br><span class="line"> <span class="comment">//TODO 发送消息时，把响应相关属性设置进去</span></span><br><span class="line"> channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>,properties,</span><br><span class="line">          msg.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;Sent error:&quot;</span>+msg);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绑定，将队列和交换器通过路由键进行绑定*/</span></span><br><span class="line">String routekey = <span class="string">&quot;error&quot;</span>;<span class="comment">/*表示只关注error级别的日志消息*/</span></span><br><span class="line">channel.queueBind(queueName,ReplyToProducer.EXCHANGE_NAME,routekey);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;waiting for message........&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明了一个消费者*/</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                               AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()</span><br><span class="line">                +<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">        <span class="comment">//TODO 从消息中拿到相关属性（确定要应答的消息ID,）</span></span><br><span class="line">        AMQP.BasicProperties respProp</span><br><span class="line">                = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .replyTo(properties.getReplyTo())</span><br><span class="line">                .correlationId(properties.getMessageId())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//TODO 消息消费时，同时需要生作为生产者生产消息（以OK为标识）</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, respProp.getReplyTo() ,</span><br><span class="line">                respProp ,</span><br><span class="line">                (<span class="string">&quot;OK,&quot;</span>+message).getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*消费者正式开始在指定队列上消费消息*/</span></span><br><span class="line">channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/study/rabbitMq/" data-id="cklhojuyn000u0csxbm7m5612" data-title="rabbitMq学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-一个hexo的示例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/%E4%B8%80%E4%B8%AAhexo%E7%9A%84%E7%A4%BA%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:33:12.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/15/%E4%B8%80%E4%B8%AAhexo%E7%9A%84%E7%A4%BA%E4%BE%8B/">一个hexo的示例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/%E4%B8%80%E4%B8%AAhexo%E7%9A%84%E7%A4%BA%E4%BE%8B/" data-id="cklhojuy900010csxge2ndt2o" data-title="一个hexo的示例" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/study/">study</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mycat/" rel="tag">mycat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/mycat/" style="font-size: 15px;">mycat</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/02/23/study/mysql3/">mysql事务隔离</a>
          </li>
        
          <li>
            <a href="/2021/02/19/study/mysql2/">一条更新sql是如何执行的</a>
          </li>
        
          <li>
            <a href="/2021/01/23/study/jvm1/">jvm认识-1</a>
          </li>
        
          <li>
            <a href="/2021/01/22/study/mysql1/">一条sql是如何执行的</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 yk<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>