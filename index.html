<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>杨凯的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="333333333333">
<meta property="og:type" content="website">
<meta property="og:title" content="杨凯的笔记">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="杨凯的笔记">
<meta property="og:description" content="333333333333">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yk">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="杨凯的笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨凯的笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">日习则学不忘，自勉则身不坠</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-study/分布式限流组件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/13/study/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2021-05-13T02:32:38.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/13/study/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6/">基于redis和lua的分布式限流组件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基于Redis和Lua的分布式限流"><a href="#基于Redis和Lua的分布式限流" class="headerlink" title="基于Redis和Lua的分布式限流"></a>基于Redis和Lua的分布式限流</h2><blockquote>
<p>之前基于guava的RateLimiter 实现的限流工具并不支持集群限流，现参考springCloud gateway实现的分布式限流。</p>
</blockquote>
<p>  如果将RateLimiter扩展，让它支持集群限流，会遇到哪些问题。<br>  RateLimiter会维护两个关键的参数nextFreeTicketMicros和storedPermits，它们分别是下一次填充时间和当前存储的令牌数。当RateLimiter的acquire函数被调用时，也就是有线程希望获取令牌时，RateLimiter会对比当前时间和nextFreeTicketMicros，根据二者差距，刷新storedPermits，然后再判断更新后的storedPermits是否足够，足够则直接返回，否则需要等待直到令牌足够(Guava RateLimiter的实现比较特殊，并不是当前获取令牌的线程等待，而是下一个获取令牌的线程等待)。</p>
<h4 id="1、脚本编写"><a href="#1、脚本编写" class="headerlink" title="1、脚本编写"></a>1、脚本编写</h4><p>令牌桶算法需要在 Redis 中存储桶的大小、当前令牌数量，并且实现每隔一段时间添加新的令牌。最简单的办法当然是每隔一段时间请求一次 Redis，将存储的令牌数量递增。<br>但实际上我们可以通过对限流两次请求之间的时间和令牌添加速度来计算得出上次请求之后到本次请求时，令牌桶应添加的令牌数量。因此我们在 Redis 中只需要存储上次请求的时间和令牌桶中的令牌数量，而桶的大小和令牌的添加速度可以通过参数传入实现动态修改。<br>由于第一次运行脚本时默认令牌桶是满的，因此可以将数据的过期时间设置为令牌桶恢复到满所需的时间，及时释放资源。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取当前key对应的最后时间和剩余令牌数</span></span><br><span class="line"><span class="keyword">local</span> ratelimit_info = redis.<span class="built_in">pcall</span>(<span class="string">&#x27;HMGET&#x27;</span>,KEYS[<span class="number">1</span>],<span class="string">&#x27;last_time&#x27;</span>,<span class="string">&#x27;current_token&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> last_time = <span class="built_in">tonumber</span>(ratelimit_info[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> current_token = <span class="built_in">tonumber</span>(ratelimit_info[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 最大令牌数</span></span><br><span class="line"><span class="keyword">local</span> max_token = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 时间范围内添加速率</span></span><br><span class="line"><span class="keyword">local</span> token_rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">local</span> current_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="comment">-- 换算公式</span></span><br><span class="line"><span class="keyword">local</span> reverse_time = <span class="number">1000</span>/token_rate</span><br><span class="line"><span class="comment">-- 如果是第一次添加令牌</span></span><br><span class="line"><span class="keyword">if</span> (current_token == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">  current_token = max_token</span><br><span class="line">  last_time = current_time</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 间隔时间</span></span><br><span class="line">  <span class="keyword">local</span> past_time = current_time-last_time</span><br><span class="line">  <span class="comment">-- 间隔时间内应该添加的令牌数</span></span><br><span class="line">  <span class="keyword">local</span> reverse_token = <span class="built_in">math</span>.<span class="built_in">floor</span>(past_time/reverse_time)</span><br><span class="line">  current_token = current_token+reverse_token</span><br><span class="line">  last_time = reverse_time*reverse_token+last_time</span><br><span class="line">  <span class="comment">-- 如果超出最大令牌数，当前令牌数设置为最大令牌数</span></span><br><span class="line">  <span class="keyword">if</span> current_token&gt;max_token <span class="keyword">then</span></span><br><span class="line">    current_token = max_token</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(current_token&gt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">  result = <span class="number">1</span></span><br><span class="line">  current_token = current_token<span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 设置新的桶状态</span></span><br><span class="line">redis.call(<span class="string">&#x27;HMSET&#x27;</span>,KEYS[<span class="number">1</span>],<span class="string">&#x27;last_time&#x27;</span>,last_time,<span class="string">&#x27;current_token&#x27;</span>,current_token)</span><br><span class="line">redis.call(<span class="string">&#x27;pexpire&#x27;</span>,KEYS[<span class="number">1</span>],<span class="built_in">math</span>.<span class="built_in">ceil</span>(reverse_time*(max_token-current_token)+(current_time-last_time)))</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>通过 RedisTemplate 对象执行脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;@annotation(requestLimiter)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint, RequestLimiter requestLimiter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 lua 脚本</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        <span class="comment">// 指定 lua 脚本</span></span><br><span class="line">        redisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;rateLimter.lua&quot;</span>)));</span><br><span class="line">        <span class="comment">// 指定返回类型</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;RateLimterHandler[分布式限流处理器]开始执行限流操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Signature signature = proceedingJoinPoint.getSignature();</span><br><span class="line">        Class&lt;?&gt; exceptionClass = requestLimiter.exceptionClass();</span><br><span class="line">        <span class="keyword">if</span> (!(signature <span class="keyword">instanceof</span> MethodSignature)) &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = exceptionClass.getConstructor(String.class);</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) constructor.newInstance(<span class="string">&quot;the Annotation @RateLimter must used on method!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">this</span>.rateLimit(redisScript, requestLimiter.key(), requestLimiter.maxPrmits(), requestLimiter.QPS());</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = exceptionClass.getConstructor(String.class);</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) constructor.newInstance(requestLimiter.exceptionMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取令牌成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceedingJoinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rateLimit</span><span class="params">(DefaultRedisScript&lt;Long&gt; redisScript, String key, <span class="keyword">int</span> max, <span class="keyword">int</span> rate)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        keyList.add(key);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(redisScript, keyList, Integer.toString(max), Integer.toString(rate),</span><br><span class="line">                        Long.toString(System.currentTimeMillis())) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>限流方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestLimiter(key = &quot;share&quot;, QPS = 1, exceptionClass = UserAlertException.class, exceptionMsg = &quot;爆了爆了爆了&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://remcarpediem.net/2019/04/06/%E5%9F%BA%E4%BA%8ERedis%E5%92%8CLua%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/">http://remcarpediem.net/2019/04/06/%E5%9F%BA%E4%BA%8ERedis%E5%92%8CLua%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/shmll/shield-ratelimter">https://github.com/shmll/shield-ratelimter</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/study/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6/" data-id="ckom9kcxt000pzzsgbw3m5gjj" data-title="基于redis和lua的分布式限流组件" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%99%90%E6%B5%81/" rel="tag">限流</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/02/study/mysql5/" class="article-date">
  <time class="dt-published" datetime="2021-03-02T11:50:38.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/02/study/mysql5/">mysql锁的认识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成文本。</p>
<p>MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL) （做备份时仅适用不支持事务的引擎，如MyISAM）。</p>
<p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。<strong>一致性读是好，但前提是引擎要支持这个可重复读隔离级别</strong></p>
<p>你也许会问，<strong>既然要全库只读，为什么不使用set global readonly=true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p>
<ul>
<li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li>
<li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁的语法是 lock tables … read/write。</strong>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<p><strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p>
<img src="/image/mysql5.1.jpg" width="100%">

<p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</p>
<p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</p>
<p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p>
<p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。</p>
<p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p>
<p>数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p>
<p>在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字段id是表t的主键。</p>
<img src="/image/mysql5.2.jpg" width="100%">

<p>这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p>
<p>知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。</p>
<p>也就是说，<strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<h1 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h1><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p>
<img src="/image/mysql5.3.jpg" width="100%">

<p>这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p>
<p>怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，<strong>死锁检测要耗费大量的CPU资源</strong>。</p>
<p><strong>控制并发度</strong>，你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/02/study/mysql5/" data-id="ckom9kcxs000mzzsgbdao3yfd" data-title="mysql锁的认识" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/DDD2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/28/study/DDD2/" class="article-date">
  <time class="dt-published" datetime="2021-02-28T05:32:38.000Z" itemprop="datePublished">2021-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/28/study/DDD2/">DDD概念体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="如何理解领域和子域？"><a href="#如何理解领域和子域？" class="headerlink" title="如何理解领域和子域？"></a>如何理解领域和子域？</h2><p>在研究和解决业务问题时，DDD 会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。简言之，<strong>DDD 的领域就是这个边界内要解决的业务问题域</strong>。</p>
<p>既然领域是用来限定业务边界和范围的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。</p>
<p>领域可以进一步划分为子领域。<strong>我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围</strong>。</p>
<h2 id="如何理解核心域、通用域和支撑域？"><a href="#如何理解核心域、通用域和支撑域？" class="headerlink" title="如何理解核心域、通用域和支撑域？"></a>如何理解核心域、通用域和支撑域？</h2><p>在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。</p>
<p>决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。还有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。</p>
<h1 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h1><p>在 DDD 中就出现了“通用语言”和“限界上下文”这两个重要的概念，<strong>通用语言定义上下文含义，限界上下文则定义领域边界</strong>，以确保每个上下文含义在它特定的边界内都具有唯一的含义，领域模型则存在于这个边界之内</p>
<h4 id="什么是通用语言？"><a href="#什么是通用语言？" class="headerlink" title="什么是通用语言？"></a>什么是通用语言？</h4><p><strong>在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言</strong>，也就是说，通用语言是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。</p>
<p>通用语言贯穿 DDD 的整个设计过程。作为项目团队沟通和协商形成的统一语言，基于它，你就能够开发出可读性更好的代码，将业务需求准确转化为代码设计。</p>
<p>这张图描述了从事件风暴建立通用语言到领域对象设计和代码落地的完整过程。</p>
<img src="/image/DDD2.1.png" width="100%">

<ol>
<li>在事件风暴的过程中，领域专家会和设计、开发人员一起建立领域模型，在领域建模的过程中会形成通用的业务术语和用户故事。事件风暴也是一个项目团队统一语言的过程。</li>
<li>通过用户故事分析会形成一个个的领域对象，这些领域对象对应领域模型的业务对象，每一个业务对象和领域对象都有通用的名词术语，并且一一映射。</li>
<li>微服务代码模型来源于领域模型，每个代码模型的代码对象跟领域对象一一对应。</li>
</ol>
<p><strong>设计过程中我们可以用一些表格，来记录事件风暴和微服务设计过程中产生的领域对象及其属性</strong>。比如，领域对象在 DDD 分层架构中的位置、属性、依赖关系以及与代码模型对象的映射关系等。</p>
<p>下面是一个微服务设计实例的部分数据，表格中的这些名词术语就是项目团队在事件风暴过程中达成一致、可用于团队内部交流的通用语言。在这个表格里面我们可以看到，DDD 分析过程中所有的领域对象以及它们的属性都被记录下来了，除了 DDD 的领域对象，我们还记录了在微服务设计过程中领域对象所对应的代码对象，并将它们一一映射。</p>
<img src="/image/DDD2.2.jpeg" width="100%">

<p>DDD 分析和设计过程中的每一个环节都需要保证限界上下文内术语的统一，在代码模型设计的时侯就要建立领域对象和代码对象的一一映射，从而<strong>保证业务模型和代码模型的一致，实现业务语言与代码语言的统一。</strong></p>
<h2 id="什么是限界上下文？"><a href="#什么是限界上下文？" class="headerlink" title="什么是限界上下文？"></a>什么是限界上下文？</h2><p>DDD 在战略设计上提出了“限界上下文”这个概念，用来确定语义所在的领域边界。</p>
<p>我们可以将限界上下文拆解为两个词：限界和上下文。限界就是领域的边界，而上下文则是语义环境。通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流。</p>
<p>综合一下，我认为限界上下文的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。<strong>领域边界就是通过限界上下文来定义的。</strong></p>
<h2 id="限界上下文和微服务的关系"><a href="#限界上下文和微服务的关系" class="headerlink" title="限界上下文和微服务的关系"></a>限界上下文和微服务的关系</h2><p>理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。</p>
<p>可以说，限界上下文是微服务设计和拆分的主要依据。在领域模型中，如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。</p>
<p>可以说，限界上下文在微服务设计中具有很重要的意义，如果限界上下文的方向偏离，那微服务的设计结果也就可想而知了。因此，我们只有理解了限界上下文的真正涵义以及它在微服务设计中的作用，才能真正发挥 DDD 的价值，这是基础也是前提。</p>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><h3 id="1-实体的业务形态"><a href="#1-实体的业务形态" class="headerlink" title="1. 实体的业务形态"></a>1. 实体的业务形态</h3><p>在 DDD 不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，实体和值对象是组成领域模型的基础单元。</p>
<h3 id="2-实体的代码形态"><a href="#2-实体的代码形态" class="headerlink" title="2. 实体的代码形态"></a>2. 实体的代码形态</h3><p>在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。在 DDD 里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。</p>
<h3 id="3-实体的运行形态"><a href="#3-实体的运行形态" class="headerlink" title="3. 实体的运行形态"></a>3. 实体的运行形态</h3><p>实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的 ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品 ID 来标识，不管这个商品的数据如何变化，商品的 ID 一直保持不变，它始终是同一个商品。</p>
<h3 id="4-实体的数据库形态"><a href="#4-实体的数据库形态" class="headerlink" title="4. 实体的数据库形态"></a>4. 实体的数据库形态</h3><p>与传统数据模型设计优先不同，DDD 是先构建领域模型，针对实际业务场景构建实体对象和行为，再将实体对象映射到数据持久化对象。</p>
<p>而在有些复杂场景下，实体与持久化对象则可能是一对多或者多对一的关系。比如，用户 user 与角色 role 两个持久化对象可生成权限实体，一个实体对应两个持久化对象，这是一对多的场景。再比如，有些场景为了避免数据库的联表查询，提升系统性能，会将客户信息 customer 和账户信息 account 两类数据保存到同一张数据库表中，客户和账户两个实体可根据需要从一个持久化对象中生成，这就是多对一的场景。</p>
<h2 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h2><p>通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。</p>
<p>简单来说，值对象本质上就是一个集。那这个集合里面有什么呢？若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎</p>
<h3 id="1-值对象的业务形态"><a href="#1-值对象的业务形态" class="headerlink" title="1. 值对象的业务形态"></a>1. 值对象的业务形态</h3><p>值对象是 DDD 领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域模型，都包含了若干个属性，它与实体一起构成聚合。</p>
<p>在值对象中也有部分共享的标准类型的值对象，它们有自己的限界上下文，有自己的持久化对象，可以建立共享的数据类微服务，比如数据字典。</p>
<h3 id="2-值对象的代码形态"><a href="#2-值对象的代码形态" class="headerlink" title="2. 值对象的代码形态"></a>2. 值对象的代码形态</h3><p>值对象在代码中有这样两种形态。如果值对象是单一属性，则直接定义为实体类的属性；如果值对象是属性集合，则把它设计为 Class 类，Class 将具有整体概念的多个属性归集到属性集合，这样的值对象没有 ID，会被实体整体引用。</p>
<p>我们看一下下面这段代码，person 这个实体有若干个单一属性的值对象，比如 Id、name 等属性；同时它也包含多个属性的值对象，比如地址 address。</p>
<img src="/image/DDD2.3.jpeg" width="100%">

<h3 id="3-值对象的运行形态"><a href="#3-值对象的运行形态" class="headerlink" title="3. 值对象的运行形态"></a>3. 值对象的运行形态</h3><p>实体实例化后的 DO 对象的业务属性和业务行为非常丰富，但值对象实例化的对象则相对简单和乏味。除了值对象数据初始化和整体替换的行为外，其它业务行为就很少了。</p>
<p>引用单一属性的值对象或只有一条记录的多属性值对象的实体，可以采用属性嵌入的方式嵌入。引用一条或多条记录的多属性值对象的实体，可以采用序列化大对象的方式嵌入。比如，人员实体可以有多个通讯地址，多个地址序列化后可以嵌入人员的地址属性。值对象创建后就不允许修改了，只能用另外一个值对象来整体替换。</p>
<h3 id="4-值对象的数据库形态"><a href="#4-值对象的数据库形态" class="headerlink" title="4. 值对象的数据库形态"></a>4. 值对象的数据库形态</h3><p>DDD 引入值对象是希望实现从“数据建模为中心”向“领域建模为中心”转变，减少数据库表的数量和表与表之间复杂的依赖关系，尽可能地简化数据库设计，提升数据库性能。</p>
<p>传统的数据建模大多是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独的一列来存储，一个实体主表会对应 N 个实体从表。而值对象在数据库持久化方面简化了设计，它的数据库设计大多采用非数据库范式，值对象的属性值和实体对象的属性值保存在同一个数据库实体表中。</p>
<p><strong>那到底应该怎样设计，才能让业务含义清楚，同时又不让数据库变得复杂呢？</strong></p>
<p>我们可以综合这两个方案的优势，扬长避短。在领域建模时，我们可以把地址作为值对象，人员作为实体，这样就可以保留地址的业务涵义和概念完整性。而在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。</p>
<p>值对象就是通过这种方式，简化了数据库设计，总结一下就是：<strong>在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。</strong></p>
<h3 id="5-值对象的优势和局限"><a href="#5-值对象的优势和局限" class="headerlink" title="5. 值对象的优势和局限"></a>5. 值对象的优势和局限</h3><p>值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询，会导致搜索值对象属性值变得异常困难。</p>
<p>值对象采用属性嵌入的方法提升了数据库的性能，但如果实体引用的值对象过多，则会导致实体堆积一堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。</p>
<h2 id="实体和值对象的关系"><a href="#实体和值对象的关系" class="headerlink" title="实体和值对象的关系"></a>实体和值对象的关系</h2><p>实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。</p>
<p>DDD 提倡从领域模型设计出发，而不是先设计数据模型。前面讲过了，传统的数据模型设计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。可以说，值对象的诞生，在一定程度上，和实体是互补的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/28/study/DDD2/" data-id="ckom9kcxf0002zzsgenatgevg" data-title="DDD概念体系" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/DDD1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/study/DDD1/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T04:32:38.000Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/26/study/DDD1/">微服务与DDD的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="软件架构模式的演进"><a href="#软件架构模式的演进" class="headerlink" title="软件架构模式的演进"></a>软件架构模式的演进</h1><p>​        我们知道，这些年来随着设备和新技术的发展，软件的架构模式发生了很大的变化。软件架构模式体来说经历了从单机、集中式到分布式微服务架构三个阶段的演进。随着分布式技术的快速兴起，我们已经进入到了微服务架构时代。</p>
<img src="/image/DDD1.1.png" width="100%">

<p><strong>第一阶段是单机架构</strong>：采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C/S 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。</p>
<p><strong>第二阶段是集中式架构</strong>：采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层,采用经典的三层架构，也有部分应用采用传统的 SOA 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。</p>
<p><strong>第三阶段是分布式微服务架构</strong>：随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。</p>
<p>我们知道，在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。</p>
<p>而且在单机和集中式架构这两种模式下，软件无法快速响应需求和业务的迅速变化，最终错失发展良机。此时，分布式微服务的出现就有点恰逢其时的意思了。</p>
<h1 id="为什么-DDD-适合微服务？"><a href="#为什么-DDD-适合微服务？" class="headerlink" title="为什么 DDD 适合微服务？"></a>为什么 DDD 适合微服务？</h1><p>​        DDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。</p>
<h3 id="DDD-包括战略设计和战术设计两部分。"><a href="#DDD-包括战略设计和战术设计两部分。" class="headerlink" title="DDD 包括战略设计和战术设计两部分。"></a>DDD 包括战略设计和战术设计两部分。</h3><p>​        DDD 战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分。事件风暴是建立领域模型的主要方法，它是一个从发散到收敛的过程。它通常采用用例分析、场景分析和用户旅程分析，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程。事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程。</p>
<img src="/image/DDD1.2.jpeg" width="100%">

<p><strong>我们可以用三步来划定领域模型和微服务的边界:</strong></p>
<p><strong>第一步</strong>：在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。</p>
<p><strong>第二步</strong>：根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。</p>
<p><strong>第三步</strong>：根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。</p>
<h2 id="DDD-与微服务的关系"><a href="#DDD-与微服务的关系" class="headerlink" title="DDD 与微服务的关系"></a>DDD 与微服务的关系</h2><p>DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。</p>
<p>DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。</p>
<p>微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。</p>
<p><strong>总体来说，DDD 可以给你带来以下收获：</strong></p>
<ol>
<li>DDD 是一套完整而系统的设计方法，它能带给你从战略设计到战术设计的标准设计过程，使得你的设计思路能够更加清晰，设计过程更加规范。</li>
<li>DDD 善于处理与领域相关的拥有高复杂度业务的产品开发，通过它可以建立一个核心而稳定的领域模型，有利于领域知识的传递与传承。</li>
<li>DDD 强调团队与领域专家的合作，能够帮助你的团队建立一个沟通良好的氛围，构建一致的架构体系。</li>
<li>DDD 的设计思想、原则与模式有助于提高你的架构设计能力。</li>
<li>无论是在新项目中设计微服务，还是将系统从单体架构演进到微服务，都可以遵循 DDD 的架构原则。</li>
<li>DDD 不仅适用于微服务，也适用于传统的单体应用。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/study/DDD1/" data-id="ckom9kcxe0001zzsg2lyd2z5l" data-title="微服务与DDD的关系" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/25/study/mysql4/" class="article-date">
  <time class="dt-published" datetime="2021-02-25T04:50:38.000Z" itemprop="datePublished">2021-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/25/study/mysql4/">mysql索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p>
<p><strong>哈希表</strong></p>
<p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p>
<p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<img src="/image/mysql4.1.png" width="80%">

<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p>
<p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<img src="/image/mysql4.2.png" width="80%">

<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p>
<img src="/image/mysql4.3.png" width="80%">

<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p>
<p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p>
<p>每一个索引在InnoDB里面对应一棵B+树。</p>
<p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引</p>
<p>这个表的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p>
<img src="/image/mysql4.4.png" width="80%">

<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p>
<p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>你一定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<p>如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p><strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p>
<p>这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p><strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p>
<p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。</p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p>
<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#39;张%&#39; and age&#x3D;10 and ismale&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图3和图4，是这两个过程的执行流程图。</p>
<img src="/image/mysql4.5.jpg" width="80%">

<p>​                                                            图3 无索引下推执行流程</p>
<img src="/image/mysql4.6.jpg" width="80%">

<p>​                                                        图4 索引下推执行流程</p>
<p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p>
<p>图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/25/study/mysql4/" data-id="ckom9kcxr000jzzsg2o02guqj" data-title="mysql索引" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/23/study/mysql3/" class="article-date">
  <time class="dt-published" datetime="2021-02-23T03:57:38.000Z" itemprop="datePublished">2021-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/23/study/mysql3/">mysql事务隔离</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p>
<ul>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<img src="/image/mysql3.1.png" width="80%">

<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<h1 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h1><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li>
<li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p>
<p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p>
<p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h1 id="mysql-可重复读的更新逻辑"><a href="#mysql-可重复读的更新逻辑" class="headerlink" title="mysql 可重复读的更新逻辑"></a>mysql 可重复读的更新逻辑</h1><p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE &#96;t&#96; (  </span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,  </span><br><span class="line">  &#96;k&#96; int(11) DEFAULT NULL,  </span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) </span><br><span class="line">) ENGINE&#x3D;InnoDB; </span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure>

<img src="/image/mysql3.2.png" width="100%">

<p>在这个例子中，事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务，<strong>语句完成的时候会自动提交</strong>。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p>
<p>这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕呢？</p>
<p>在MySQL里，有两个“视图”的概念：</p>
<ul>
<li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li>
<li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p>
<p><strong>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</strong></p>
<p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
<p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p>
<p><strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p>
<p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p>
<p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k=k+1是在（1,2）的基础上进行的操作。</p>
<p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p>
<p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p>
<p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是当前读。</p>
<p>所以，如果把事务A的查询语句select * from t where id=1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select k from t where id&#x3D;1 lock in share mode; </span><br><span class="line">mysql&gt; select k from t where id&#x3D;1 for update;</span><br></pre></td></tr></table></figure>

<p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p>
<img src="/image/mysql3.3.png" width="100%">

<p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p>
<p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/23/study/mysql3/" data-id="ckom9kcxq000hzzsgbyfkhp5a" data-title="mysql事务隔离" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/19/study/mysql2/" class="article-date">
  <time class="dt-published" datetime="2021-02-19T03:41:38.000Z" itemprop="datePublished">2021-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/19/study/mysql2/">一条更新sql是如何执行的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将ID=2这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c&#x3D;c+1 where ID&#x3D;2; </span><br></pre></td></tr></table></figure>

<p>前面我有跟你介绍过SQL语句基本的执行链路。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h1 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h1><p><strong>WAL技术</strong>（Write-Ahead Logging）：</p>
<p>它的关键点就是先写日志，再写磁盘。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<img src="/image/mysql2.1.jpg" width="80%">

<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h1 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h1><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li><p>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</p>
<img src="/image/mysql2.2.png" width="80%">

<p>​                                                        update语句执行流程</p>
</li>
</ol>
<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>
<h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ol>
<li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li>
<li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p>
<p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p>
<p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/19/study/mysql2/" data-id="ckom9kcxm000czzsg14e5aofq" data-title="一条更新sql是如何执行的" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/jvm1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/23/study/jvm1/" class="article-date">
  <time class="dt-published" datetime="2021-01-23T07:41:38.000Z" itemprop="datePublished">2021-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/23/study/jvm1/">jvm认识-1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="Java-虚拟机具体是怎样运行-Java-字节码的？"><a href="#Java-虚拟机具体是怎样运行-Java-字节码的？" class="headerlink" title="Java 虚拟机具体是怎样运行 Java 字节码的？"></a>Java 虚拟机具体是怎样运行 Java 字节码的？</h4><p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟<br>机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执<br>行方法区内的代码。</p>
<p>如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同<br>样也在内存中划分出堆和栈来存储运行时数据。</p>
<p>不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用<br>C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。</p>
<p><img src="/image/jvm1.1.png" alt="image-20210223135452884"></p>
<p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中<br>生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，<br>而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p>
<p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程<br>的当前栈帧，并将之舍弃。</p>
<p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器<br>码。</p>
<p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成<br>机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中<br>包含的所有字节码编译成机器码后再执行。</p>
<p><img src="/image/jvm1.2.png" alt="image-20210223135652372"></p>
<p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用<br>混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反<br>复执行的热点代码，以方法为单位进行即时编译。</p>
<h4 id="Java虚拟机是如何加载Java类的"><a href="#Java虚拟机是如何加载Java类的" class="headerlink" title="Java虚拟机是如何加载Java类的?"></a>Java虚拟机是如何加载Java类的?</h4><p><strong>加载</strong></p>
<p>加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对<br>应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助<br>类加载器来完成查找字节流的过程。</p>
<p>启动类加载器（bootstrapclass loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中，只能用 null 来指代。</p>
<p>除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应<br>的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java<br>虚拟机中，方能执行类加载。</p>
<p>双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p>
<p>在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib<br>目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载<br>器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加<br>载器（application class loader），均由 Java 核心类库提供。</p>
<p>扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存<br>放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。</p>
<p>应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的<br>应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量<br>CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载<br>的。</p>
<p>Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类<br>加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base<br>是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p>
<p>除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊<br>的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器。</p>
<p><strong>链接</strong></p>
<p>链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准<br>备以及解析三个阶段。</p>
<p>验证：验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。</p>
<p>准备：准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初<br>始化，则会在稍后的初始化阶段中进行。</p>
<p>除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如<br>说用来实现虚方法的动态绑定的方法表。</p>
<p>在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的<br>具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编<br>译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标<br>上。</p>
<p>解析： 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载<br>的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的<br>链接以及初始化。）</p>
<p><strong>初始化</strong></p>
<p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态<br>代码块中对其赋值。</p>
<p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字<br>段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完<br>成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同<br>一方法中，并把它命名为 &lt; clinit &gt;。</p>
<p>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的<br>过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。</p>
<p>那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p>
<ol>
<li>当虚拟机启动时，初始化用户指定的主类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，<br>会触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ol>
<p>Q:</p>
<p>1:为什么使用JVM？<br>1-1:可以轻松实现Java代码的跨平台执行<br>1-2:JVM提供了一个托管平台，提供内存管理、垃圾回收、编译时动态校验等功能<br>1-3:使用JVM能够让我们的编程工作更轻松、高效节省公司成本，提示社会化的整体快发效率，我们只关注和业务相关的程序逻辑的编写，其他业务无关但对于编程同样重要的事情交给JVM来处理</p>
<p>2.热点代码和非热点代码：</p>
<p>看到有人说热点代码的区别，在git里面涉及到的热点代码有两种算法，基于采样的热点探测和基于计数器的热点探测。一般采用的都是基于计数器的热点探测，两者的优缺点百度一下就知道了。基于计数器的热点探测又有两个计数器，方法调用计数器，回边计数器，他们在C1和C2又有不同的阈值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/23/study/jvm1/" data-id="ckom9kcxi0005zzsghmk56xyk" data-title="jvm认识-1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/mysql1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/22/study/mysql1/" class="article-date">
  <time class="dt-published" datetime="2021-01-22T03:41:38.000Z" itemprop="datePublished">2021-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/22/study/mysql1/">一条sql是如何执行的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p>
<img src="/image/mysql1.1.png" width="80%">

<p>​                                                                        mysql 的逻辑架构图</p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。</p>
<h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <strong>Lost connection to MySQL server during query</strong>。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用<strong>长连接</strong>。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为<strong>MySQL在执行过程中临时使用的内存是管理在连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<ol>
<li><strong>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</strong></li>
<li><strong>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</strong></li>
</ol>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID&#x3D;10；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID&#x3D;1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
<h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c&#x3D;10 and t2.d&#x3D;20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID&#x3D;10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/22/study/mysql1/" data-id="ckom9kcxl000bzzsgggzp1wht" data-title="一条sql是如何执行的" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-study/rabbitMq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/15/study/rabbitMq/" class="article-date">
  <time class="dt-published" datetime="2020-12-15T02:40:38.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/15/study/rabbitMq/">rabbitMq学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="rabbitMq："><a href="#rabbitMq：" class="headerlink" title="rabbitMq："></a>rabbitMq：</h2><blockquote>
<p>优点：解耦，异步，缓冲，伸缩性，扩展性</p>
<p>与Rpc的区别：Rpc同步，mq异步        </p>
</blockquote>
<h3 id="rabbitMq概念："><a href="#rabbitMq概念：" class="headerlink" title="rabbitMq概念："></a>rabbitMq概念：</h3><ul>
<li>Broker:标识消息队列服务器实体。</li>
<li>Virtual Host：虚拟主机， 每个vhost本质上就是一个mini版的RabbitMQ服务器。</li>
<li>Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li>
<li>Queue:消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>
<li>Banding：绑定，用于消息队列和交换机之间的关联，一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li>
<li>Channel：信道，多路复用连接中的一条独立的双向数据流通道</li>
</ul>
<h2 id="Exchange分发策略"><a href="#Exchange分发策略" class="headerlink" title="Exchange分发策略"></a>Exchange分发策略</h2><ul>
<li><p>direct:消息中的路由键如果和Binding中的binding key一致，交换器就将消息发到对应的队列中。路由键                                  与队列名完全匹配。(完全匹配)</p>
</li>
<li><p>fanout(广播):每个发到fanout类型交换器的消息都会分到所有绑定的队列上去</p>
</li>
<li><p>topic:必须由（.）分割的单词列表。比如apple.banana.orange</p>
<blockquote>
<p>可以代替一个单词。</p>
<p> #可以代替零个或多个单词。</p>
</blockquote>
</li>
</ul>
<img src="/image/截图.png" width="70%">

<h1 id="交换器（原生客户端）"><a href="#交换器（原生客户端）" class="headerlink" title="交换器（原生客户端）"></a>交换器（原生客户端）</h1><h3 id="Direct交换器："><a href="#Direct交换器：" class="headerlink" title="Direct交换器："></a>Direct交换器：</h3><h4 id="product"><a href="#product" class="headerlink" title="product:"></a>product:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接、连接到RabbitMQ</span></span><br><span class="line">ConnectionFactory connectionFactory= <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置下连接工厂的连接地址(使用默认端口5672)</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection =connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建信道</span></span><br><span class="line">Channel channel =connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_logs&quot;</span>,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明队列（放在消费者中去做）</span></span><br><span class="line"><span class="comment">//申明路由键\消息体</span></span><br><span class="line">String[] routeKeys =&#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    String routeKey = routeKeys[i%<span class="number">3</span>];</span><br><span class="line">    String msg = <span class="string">&quot;Hello,RabbitMQ&quot;</span>+(i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发布消息 </span></span><br><span class="line"> channel.basicPublish(<span class="string">&quot;direct_logs&quot;</span>,routeKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;Sent:&quot;</span>+routeKey+<span class="string">&quot;:&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer:"></a>consumer:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接、连接到RabbitMQ</span></span><br><span class="line">ConnectionFactory connectionFactory= <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置下连接工厂的连接地址(使用默认端口5672)</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection =connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建信道</span></span><br><span class="line">Channel channel =connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_logs&quot;</span>,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明队列（放在消费者中去做）</span></span><br><span class="line">String queueName=<span class="string">&quot;queue-a&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定：将队列(queuq-a)与交换器通过 路由键 绑定(aaa)</span></span><br><span class="line">String routeKey =<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">channel.queueBind(queueName,DirectProducer.EXCHANGE_NAME,routeKey);</span><br><span class="line">System.out.println(<span class="string">&quot;waiting for message ......&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明一个消费者</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer  = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String s, Envelope envelope, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()+<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消息者正是开始在指定队列上消费。(queue-a)</span></span><br><span class="line"><span class="comment">//TODO 这里第二个参数是自动确认参数，如果是true则是自动确认</span></span><br><span class="line">channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure>

<h3 id="fanout-交换器"><a href="#fanout-交换器" class="headerlink" title="fanout 交换器"></a>fanout 交换器</h3><p>routeKey无论设置为任何键，消息都会发到每一个队列</p>
<h3 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h3><blockquote>
<p> *与#的区别：如果我们发送的路由键变成king.kafka.A,那么队列中如果绑定了king.* 不能匹配队列中如果绑定了king.# 能够匹配</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 根据需求绑定不同routeKey</span></span><br><span class="line">channel.queueBind(queueName,TopicProducer.EXCHANGE_NAME, <span class="string">&quot;king.#&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="消息发布和消费的权衡"><a href="#消息发布和消费的权衡" class="headerlink" title="消息发布和消费的权衡"></a>消息发布和消费的权衡</h1><h2 id="发布时的权衡："><a href="#发布时的权衡：" class="headerlink" title="发布时的权衡："></a>发布时的权衡：</h2><p>在RabbitMQ 中，有不同的投递机制（生产者），但是每一种机制都对性能有一定的影响。一般来讲速度快的可靠性低，可靠性好的性能差，具体怎么使用需要根据你的应用程序来定，所以说没有最好的方式，只有最合适的方式。只有把你的项目和技术相结合，才能找到适合你的平衡。</p>
<img src="/image/WechatIMG8525.png" width="100%">

<h4 id="1-无保障："><a href="#1-无保障：" class="headerlink" title="1.无保障："></a>1.无保障：</h4><p><em>在演示各种交换器中使用的就是无保障的方式，通过basicPublish 发布你的消息并使用正确的交换器和路由信息，你的消息会被接收并发送到合适的队列中。但是如果有网络问题，或者消息不可路由，或者RabbitMQ 自身有问题的话，这种方式就有风险。所以无保证的消息发送一般情况下不推荐。</em></p>
<h4 id="2-失败确认"><a href="#2-失败确认" class="headerlink" title="2.失败确认"></a>2.失败确认</h4><p><em>在发送消息时设置mandatory 标志，告诉RabbitMQ，如果消息不可路由，应该将消息返回给发送者，并通知失败。可以这样认为，开启mandatory是开启故障检测模式。</em></p>
<blockquote>
<p>注意：它只会让RabbitMQ 向你通知失败，而不会通知成功。如果消息正确路由到队列，则发布者不会受到任何通知。带来的问题是无法确保发布消息一定是成功的，因为通知失败的消息可能会丢失。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//失败通知 回调</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replycode, String replyText, String exchange, String routeKey, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回的replycode:&quot;</span>+replycode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//TODO 第三个参数mandatory设置为true,开启故障检测模式 </span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,routekey,<span class="keyword">true</span>,<span class="keyword">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>

<h4 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h4><p><em>事务的实现主要是对信道（Channel）的设置，主要的方法有三个：</em></p>
<ol>
<li><p>channel.txSelect()声明启动事务模式；</p>
</li>
<li><p>channel.txComment()提交事务；</p>
</li>
<li><p>channel.txRollback()回滚事务；</p>
</li>
</ol>
<p><em>在发送消息之前，需要声明channel 为事务模式，提交或者回滚事务即可。开启事务后，客户端和RabbitMQ 之间的通讯交互流程：</em></p>
<ul>
<li><p>客户端发送给服务器Tx.Select(开启事务模式)</p>
</li>
<li><p>服务器端返回Tx.Select-Ok（开启事务模式ok）</p>
</li>
<li><p>推送消息</p>
</li>
<li><p>客户端发送给事务提交Tx.Commit</p>
</li>
<li><p> 服务器端返回Tx.Commit-Ok</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入事务</span></span><br><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        String routekey = routekeys[i%<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 发送的消息</span></span><br><span class="line">        String message = <span class="string">&quot;Hello World_&quot;</span>+(i+<span class="number">1</span>)</span><br><span class="line">                +(<span class="string">&quot;_&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routekey, <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: [&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事务提交</span></span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="comment">//事务回滚</span></span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么，既然已经有事务了，为何还要使用发送方确认模式呢，原因是因为事务的性能是非常差的。根据相关资料，事务会降低2~10 倍的性能。</p>
</blockquote>
<h4 id="4-发送发确认模式："><a href="#4-发送发确认模式：" class="headerlink" title="4.发送发确认模式："></a>4.发送发确认模式：</h4><p><em>基于事务的性能问题，RabbitMQ 团队为我们拿出了更好的方案，即采用发送方确认模式，该模式比事务更轻量，性能影响几乎可以忽略不计。原理：生产者将信道设置成confirm 模式，一旦信道进入confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1 开始)，由这个id 在生产者和RabbitMQ 之间进行消息的确认。不可路由的消息，当交换器发现，消息不能路由到任何队列，会进行确认操作，表示收到了消息。如果发送方设置了mandatory 模式,则会先调用addReturnListener 监听器。</em></p>
<p><em>可路由的消息，要等到消息被投递到所有匹配的队列之后，broker 会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中delivery-tag 域包含了确认消息的序列号。</em></p>
<p><em>confirm 模式最大的好处在于他可以是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack 消息，生产者应用程序同样可以在回调方法中处理该nack 消息决定下一步的处理。</em></p>
<h5 id="Confirm-的三种实现方式："><a href="#Confirm-的三种实现方式：" class="headerlink" title="Confirm 的三种实现方式："></a>Confirm 的三种实现方式：</h5><ul>
<li>方式一：channel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//确认是否成功(true成功)</span></span><br><span class="line"><span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;send success&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;send failure&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：channel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException 异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用发送者确认模式（批量确认）</span></span><br><span class="line">channel.waitForConfirmsOrDie();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方式三：channel.addConfirmListener()异步监听发送方确认模式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO启用发送者确认模式 </span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//TODO添加发送者确认监听器</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">    <span class="comment">//TODO 成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;     System.out.println(<span class="string">&quot;send_ACK:&quot;</span>+deliveryTag+<span class="string">&quot;,multiple:&quot;</span>+multiple);&#125;</span><br><span class="line">    <span class="comment">//TODO 失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Erro----send_NACK:&quot;</span>+deliveryTag+<span class="string">&quot;,multiple:&quot;</span>+multiple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-备用交换器"><a href="#5-备用交换器" class="headerlink" title="5.备用交换器"></a>5.备用交换器</h4><p><em>在第一次声明交换器时被指定，用来提供一种预先存在的交换器，如果主交换器无法路由消息，那么消息将被路由到这个新的备用交换器。使用备用交换器，向往常一样，声明Queue 和备用交换器，把Queue 绑定到备用交换器上。然后在声明主交换器时，通过交换器的参数，alternate-exchange,，将备用交换器设置给主交换器。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明备用交换器</span></span><br><span class="line">Map&lt;String,Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">argsMap.put(<span class="string">&quot;alternate-exchange&quot;</span>,<span class="string">&quot;ae&quot;</span>);</span><br><span class="line"><span class="comment">//主交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;main-exchange&quot;</span>,<span class="string">&quot;direct&quot;</span>,</span><br><span class="line">        <span class="keyword">false</span>,<span class="keyword">false</span>,argsMap);</span><br><span class="line"><span class="comment">//备用交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;ae&quot;</span>,BuiltinExchangeType.FANOUT,</span><br><span class="line">        <span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="消息的消费权衡"><a href="#消息的消费权衡" class="headerlink" title="消息的消费权衡"></a>消息的消费权衡</h2><img src="/image/WechatIMG8528.png" width="80%">

<h3 id="消息的获取方式"><a href="#消息的获取方式" class="headerlink" title="消息的获取方式"></a>消息的获取方式</h3><h4 id="拉取Get"><a href="#拉取Get" class="headerlink" title="拉取Get"></a>拉取Get</h4><p>_属于一种轮询模型，发送一次get 请求，获得一个消息。如果此时RabbitMQ 中没有消息，会获得一个表示空的回复。总的来说，这种方式性能比较差，很明显，每获得一条消息，都要和RabbitMQ 进行网络通信发出请求。而且对RabbitMQ 来说，RabbitMQ 无法进行任何优化，因为它永远不知道应用程序何时会发出请求。具体使用，参见代码native 模块包cn.enjoyedu.consumer_balance.GetMessage 中。对我们实现者来说，要在一个循环里，不断去服务器get 消息。_</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 无限循环拉取</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//拉一条，自动确认的(rabbit 认为这条消息消费 -- 从队列中删除)</span></span><br><span class="line">    GetResponse getResponse = channel.basicGet(queueName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>!=getResponse)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;received[&quot;</span></span><br><span class="line">                +getResponse.getEnvelope().getRoutingKey()+<span class="string">&quot;]&quot;</span></span><br><span class="line">                +<span class="keyword">new</span> String(getResponse.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确认(自动、手动)</span></span><br><span class="line">    channel.basicAck(<span class="number">0</span>,<span class="keyword">true</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="推送Consume"><a href="#推送Consume" class="headerlink" title="推送Consume"></a>推送Consume</h4><p><em>属于一种推送模型。注册一个消费者后，RabbitMQ 会在消息可用时，自动将消息进行推送给消费者。</em></p>
<h4 id="消息的应答"><a href="#消息的应答" class="headerlink" title="消息的应答"></a>消息的应答</h4><p><em>前面说过，消费者收到的每一条消息都必须进行确认。消息确认后，RabbitMQ 才会从队列删除这条消息，RabbitMQ 不会为未确认的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是<strong>消费该消息的消费者连接是否已经断开</strong>。这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</em></p>
<h4 id="自动确认"><a href="#自动确认" class="headerlink" title="自动确认"></a>自动确认</h4><p><em>消费者在声明队列时，可以指定autoAck 参数，当autoAck=true 时，一旦消费者接收到了消息，就视为自动确认了消息。如果消费者在处理消息的过程中，出了错，就没有什么办法重新处理这条消息，所以我们很多时候，需要在消息处理成功后，再确认消息，这就需要手动确认。</em></p>
<h4 id="手动确认"><a href="#手动确认" class="headerlink" title="手动确认"></a>手动确认</h4><p>​        <em>当autoAck=false 时，RabbitMQ 会等待消费者显式发回ack 信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ 会在队列中消息被消费后立即删除它。</em>    </p>
<p>​        <em>采用消息确认机制后，只要令autoAck=false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ 会一直持有消息直到消费者显式调用basicAck 为止。</em></p>
<p>​        <em>当autoAck=false 时，对于RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者ack 信号的消息。如果服务器端一直没有收到消费者的ack 信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*声明了一个消费者*/</span></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params"> Envelope envelope,AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);                   System.out.println(<span class="string">&quot;Received&quot;</span>+message);</span><br><span class="line">                    <span class="comment">//确认</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//拒绝</span></span><br><span class="line"><span class="comment">//Reject方式拒绝，第二个参数决定是否重新投递</span></span><br><span class="line">channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*消费者正式开始在指定队列上消费消息*/</span></span><br><span class="line">        <span class="comment">//TODO 这里第二个参数是自动确认参数，如果是false则是手动确认</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">false</span>,consumer);</span><br></pre></td></tr></table></figure>

<h4 id="QoS-预取模式"><a href="#QoS-预取模式" class="headerlink" title="QoS 预取模式"></a>QoS 预取模式</h4><p><em>在确认消息被接收之前，消费者可以预先要求接收一定数量的消息，在处理完一定数量的消息后，批量进行确认。如果消费者应用程序在确认消息之前崩溃，则所有未确认的消息将被重新发送给其他消费者。所以这里存在着一定程度上的可靠性风险。这种机制一方面可以实现限速（将消息暂存到RabbitMQ 内存中）的作用，一方面可以保证消息确认质量（比如确认了但是处理有异常的情况）。</em></p>
<blockquote>
<p>注意：消费确认模式必须是非自动ACK 机制（这个是使用baseQos 的前提条件，否则会Qos 不生效），然后设置basicQos 的值；另外，还可以基于consume 和channel 的粒度进行设置（global）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量确认 -----消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchAckConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计数，第多少条</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> meesageCount =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchAckConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消费者启动了......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">      Envelope envelope,AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//把消息体拉出来</span></span><br><span class="line">        String message = <span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> System.out.println(message);</span><br><span class="line">        meesageCount++;</span><br><span class="line">        <span class="comment">//批量确认 50一批</span></span><br><span class="line">        <span class="keyword">if</span>(meesageCount %<span class="number">50</span> ==<span class="number">0</span>)&#123;        <span class="keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;批量消息费进行消息的确认------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果是最后一条消息，则把剩余的消息都进行确认</span></span><br><span class="line">       <span class="keyword">if</span>(message.equals(<span class="string">&quot;stop&quot;</span>))&#123;         <span class="keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;批量消费者进行最后业务消息的确认---------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息的拒绝"><a href="#消息的拒绝" class="headerlink" title="消息的拒绝"></a>消息的拒绝</h2><blockquote>
<p>Reject 和 N a c k  </p>
</blockquote>
<p>​        消息确认可以让RabbitMQ 知道消费者已经接受并处理完消息。但是如果消息本身或者消息的处理过程出现问题怎么办？需要一种机制，通知RabbitMQ，这个消息，我无法处理，请让别的消费者处理。这里就有两种机制，Reject 和Nack。Reject 在拒绝消息时，可以使用requeue 标识，告诉RabbitMQ 是否需要重新发送给别的消费者。如果是false 则不重新发送，一般这个消息就会被RabbitMQ 丢弃。Reject 一次只能拒绝一条消息。如果是true 则消息发生了重新投递。</p>
<p>​        Nack 跟Reject 类似，只是它可以一次性拒绝多个消息。也可以使用requeue 标识，这是RabbitMQ 对AMQP 规范的一个扩展。具体使用，当requeue参数设置为true 时，消息发生了重新投递。当requeue 参数设置为false 时，消息丢失了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reject方式拒绝，第二个参数决定是否重新投递</span></span><br><span class="line">channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">true</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//Nack方式拒绝，第二个参数决定是否批量,第三参数是否重新投递</span></span><br><span class="line">channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="死信交换器（DLX）"><a href="#死信交换器（DLX）" class="headerlink" title="死信交换器（DLX）"></a>死信交换器（DLX）</h2><blockquote>
<p>1.过期消息</p>
<p>2.消息队列达到最大长度，最开始的投递的消息</p>
<p>3.拒绝且requeue = false的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定死信交换器</span></span><br><span class="line">channel.exchageDeclare(DlxProducer.EXCHAGE_NAME, BuiltinExchageType.TOPIC);</span><br><span class="line"><span class="comment">//申明队列</span></span><br><span class="line">String queueName = <span class="string">&quot;dlx_make&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchage&quot;</span>, <span class="string">&quot;死信交换器名称&quot;</span>);</span><br><span class="line"><span class="comment">//TODO 死信路由键会替换原来路由键</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,args);</span><br><span class="line"><span class="comment">//将队列和交换器通过路由键绑定</span></span><br><span class="line">channel.queueBind(queueName,DlxProducer.EXCHAGE_NAME, <span class="string">&quot;#&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="死信交换器和备用交换器的区别"><a href="#死信交换器和备用交换器的区别" class="headerlink" title="死信交换器和备用交换器的区别"></a><strong>死信交换器和备用交换器的区别</strong></h4><blockquote>
<p>备用交换器是备胎：没有队列要它的时候只能选择备用交换器。死信交换器是老实人：消息已经被消费者玩过一遍，消费者没有消费，只能被死信交换器接收。</p>
</blockquote>
<h3 id="控制队列"><a href="#控制队列" class="headerlink" title="控制队列"></a>控制队列</h3><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><p><em>临时队列对应的是没有持久化的队列，也就是如果RabbitMQ 服务器重启，那么这些队列就不会存在，所以我们称之为临时队列。</em></p>
<h4 id="自动删除队列"><a href="#自动删除队列" class="headerlink" title="自动删除队列"></a>自动删除队列</h4><p><em>自动删除队列和普通队列在使用上没有什么区别，唯一的区别是，当消费者断开连接时，队列将会被删除。自动删除队列允许的消费者没有限制，也就是说当这个队列上最后一个消费者断开连接才会执行删除。</em></p>
<blockquote>
<p>自动删除队列只需要在声明队列时，设置属性auto-delete 标识为true 即可。系统声明的随机队列，缺省就是自动删除的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四个参数</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="单消费者队列"><a href="#单消费者队列" class="headerlink" title="单消费者队列"></a>单消费者队列</h4><p><em>普通队列允许的消费者没有限制，多个消费者绑定到多个队列时，RabbitMQ 会采用轮询进行投递。如果需要消费者独占队列，在队列创建的时候，设定属性exclusive 为true。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自动过期队列"><a href="#自动过期队列" class="headerlink" title="自动过期队列"></a>自动过期队列</h4><p><em>指队列在超过一定时间没使用，会被从RabbitMQ 中被删除。</em></p>
<p><em>什么是没使用？1.一定时间内没有Get 操作发生。2.没有Consumer 连接在队列上。特别的：就算一直有消息进入队列，也不算队列在被使用。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO /*自动过期队列--参数需要Map传递*/</span></span><br><span class="line">String queueName = <span class="string">&quot;setQueue&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-expires&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//10秒被删除</span></span><br><span class="line"><span class="comment">//TODO 队列的各种参数</span></span><br><span class="line"><span class="comment">/*加入队列的各种参数*/</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,arguments);</span><br></pre></td></tr></table></figure>

<h4 id="永久队列"><a href="#永久队列" class="headerlink" title="永久队列"></a>永久队列</h4><p><em>持久化队列和非持久化队列的区别是，持久化队列会被保存在磁盘中，固定并持久的存储，当Rabbit 服务重启后，该队列会保持原来的状态在RabbitMQ中被管理，而非持久化队列不会被保存在磁盘中，Rabbit 服务重启后队列就会消失。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将属性durable 设置为“true”，</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="队列级别消息过期"><a href="#队列级别消息过期" class="headerlink" title="队列级别消息过期"></a>队列级别消息过期</h4><p><em>就是为每个队列设置消息的超时时间。只要给队列设置x-message-ttl 参数，就设定了该队列所有消息的存活时间，时间单位是毫秒。如果声明队列时指定了死信交换器，则过期消息会成为死信消息。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO /*自动过期队列--参数需要Map传递*/</span></span><br><span class="line">String queueName = <span class="string">&quot;setQueue&quot;</span>;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-expires&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//10秒被删除</span></span><br><span class="line"><span class="comment">//设定该队列消息存活时间，时间单位毫秒</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//消息10秒被删除</span></span><br><span class="line"><span class="comment">//TODO 队列的各种参数</span></span><br><span class="line"><span class="comment">/*加入队列的各种参数*/</span></span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,arguments);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对队列中消息的条数进行限制x-max-length</p>
</li>
<li><p>对队列中消息的总量进行限制x-max-length-bytes</p>
</li>
</ul>
<h3 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h3><p><em>默认情况下，队列和交换器在服务器重启后都会消失，消息当然也是。将队列和交换器的durable 属性设为true，缺省为false，但是消息要持久化还不够，还需要将消息在发布前，将投递模式设置为2。消息要持久化，必须要有持久化的队列、交换器和投递模式都为2。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 创建持久化交换器 durable=true</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;direct&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//TODO 发布持久化的消息(delivery-mode=2)</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,routekey,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        msg.getBytes());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 声明一个持久化队列(durable=true)</span></span><br><span class="line">String queueName = <span class="string">&quot;msgdurable&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,</span><br><span class="line">        <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Request-Response-模式"><a href="#Request-Response-模式" class="headerlink" title="Request-Response 模式"></a>Request-Response 模式</h3><p>​        <em>我们前面的学习模式中都是一方负责发送消息而另外一方负责处理。而我们实际中的很多应用相当于一种一应一答的过程，需要双方都能给对方发送消息。于是请求-应答的这种通信方式也很重要。它也应用的很普遍。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 响应QueueName ，消费者将会把要返回的信息发送到该Queue</span></span><br><span class="line">String responseQueue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//TODO 消息的唯一id</span></span><br><span class="line">String msgId = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//TODO 设置消息中的应答属性</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">  <span class="comment">//replyTO构建回复消息的私有响应队列</span></span><br><span class="line">        .replyTo(responseQueue)</span><br><span class="line">        .messageId(msgId)</span><br><span class="line">        .build();</span><br><span class="line"> <span class="comment">/*声明了一个消费者*/</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()</span><br><span class="line">                        +<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//TODO 消费者应答队列上的消息</span></span><br><span class="line">channel.basicConsume(responseQueue,<span class="keyword">true</span>,consumer);</span><br><span class="line"> String msg = <span class="string">&quot;Hello,RabbitMq&quot;</span>;</span><br><span class="line"> <span class="comment">//TODO 发送消息时，把响应相关属性设置进去</span></span><br><span class="line"> channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>,properties,</span><br><span class="line">          msg.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;Sent error:&quot;</span>+msg);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绑定，将队列和交换器通过路由键进行绑定*/</span></span><br><span class="line">String routekey = <span class="string">&quot;error&quot;</span>;<span class="comment">/*表示只关注error级别的日志消息*/</span></span><br><span class="line">channel.queueBind(queueName,ReplyToProducer.EXCHANGE_NAME,routekey);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;waiting for message........&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明了一个消费者*/</span></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                               AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received[&quot;</span>+envelope.getRoutingKey()</span><br><span class="line">                +<span class="string">&quot;]&quot;</span>+message);</span><br><span class="line">        <span class="comment">//TODO 从消息中拿到相关属性（确定要应答的消息ID,）</span></span><br><span class="line">        AMQP.BasicProperties respProp</span><br><span class="line">                = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .replyTo(properties.getReplyTo())</span><br><span class="line">                .correlationId(properties.getMessageId())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//TODO 消息消费时，同时需要生作为生产者生产消息（以OK为标识）</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, respProp.getReplyTo() ,</span><br><span class="line">                respProp ,</span><br><span class="line">                (<span class="string">&quot;OK,&quot;</span>+message).getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*消费者正式开始在指定队列上消费消息*/</span></span><br><span class="line">channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/study/rabbitMq/" data-id="ckom9kcy0001dzzsgdd1r8n09" data-title="rabbitMq学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/study/">study</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mycat/" rel="tag">mycat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%99%90%E6%B5%81/" rel="tag">限流</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/DDD/" style="font-size: 15px;">DDD</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/mycat/" style="font-size: 15px;">mycat</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 10px;">限流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/13/study/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6/">基于redis和lua的分布式限流组件</a>
          </li>
        
          <li>
            <a href="/2021/03/02/study/mysql5/">mysql锁的认识</a>
          </li>
        
          <li>
            <a href="/2021/02/28/study/DDD2/">DDD概念体系</a>
          </li>
        
          <li>
            <a href="/2021/02/26/study/DDD1/">微服务与DDD的关系</a>
          </li>
        
          <li>
            <a href="/2021/02/25/study/mysql4/">mysql索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 yk<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>