---
title: jvm认识-1
date: 2021-01-23 15:41:38
categories: study
tags: [jvm]
---

#### Java 虚拟机具体是怎样运行 Java 字节码的？

从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟
机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执
行方法区内的代码。

如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同
样也在内存中划分出堆和栈来存储运行时数据。

不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用
C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。

![image-20210223135452884](/image/jvm1.1.png)

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中
生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，
而且 Java 虚拟机不要求栈帧在内存空间里连续分布。

当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程
的当前栈帧，并将之舍弃。

从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器
码。

在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成
机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中
包含的所有字节码编译成机器码后再执行。

![image-20210223135652372](/image/jvm1.2.png)

前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用
混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反
复执行的热点代码，以方法为单位进行即时编译。



#### Java虚拟机是如何加载Java类的?

**加载**

加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对
应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助
类加载器来完成查找字节流的过程。

启动类加载器（bootstrapclass loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中，只能用 null 来指代。

除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应
的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java
虚拟机中，方能执行类加载。

双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib
目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载
器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加
载器（application class loader），均由 Java 核心类库提供。

扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存
放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。

应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的
应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量
CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载
的。

Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类
加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base
是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊
的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器。

**链接**

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准
备以及解析三个阶段。

验证：验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。

准备：准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初
始化，则会在稍后的初始化阶段中进行。

除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如
说用来实现虚方法的动态绑定的方法表。

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的
具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编
译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标
上。

解析： 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载
的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的
链接以及初始化。）

**初始化**

在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态
代码块中对其赋值。

如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字
段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完
成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同
一方法中，并把它命名为 < clinit >。

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的
过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。



那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：
1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，
会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

Q:

1:为什么使用JVM？
1-1:可以轻松实现Java代码的跨平台执行
1-2:JVM提供了一个托管平台，提供内存管理、垃圾回收、编译时动态校验等功能
1-3:使用JVM能够让我们的编程工作更轻松、高效节省公司成本，提示社会化的整体快发效率，我们只关注和业务相关的程序逻辑的编写，其他业务无关但对于编程同样重要的事情交给JVM来处理

2.热点代码和非热点代码：

看到有人说热点代码的区别，在git里面涉及到的热点代码有两种算法，基于采样的热点探测和基于计数器的热点探测。一般采用的都是基于计数器的热点探测，两者的优缺点百度一下就知道了。基于计数器的热点探测又有两个计数器，方法调用计数器，回边计数器，他们在C1和C2又有不同的阈值。