---
title: 基于redis和lua的分布式限流组件
date: 2021-05-13 10:32:38
categories: study
tags: [限流]
---

## 基于Redis和Lua的分布式限流

>之前基于guava的RateLimiter 实现的限流工具并不支持集群限流，现参考springCloud gateway实现的分布式限流。

  如果将RateLimiter扩展，让它支持集群限流，会遇到哪些问题。
  RateLimiter会维护两个关键的参数nextFreeTicketMicros和storedPermits，它们分别是下一次填充时间和当前存储的令牌数。当RateLimiter的acquire函数被调用时，也就是有线程希望获取令牌时，RateLimiter会对比当前时间和nextFreeTicketMicros，根据二者差距，刷新storedPermits，然后再判断更新后的storedPermits是否足够，足够则直接返回，否则需要等待直到令牌足够(Guava RateLimiter的实现比较特殊，并不是当前获取令牌的线程等待，而是下一个获取令牌的线程等待)。

 #### 1、脚本编写
令牌桶算法需要在 Redis 中存储桶的大小、当前令牌数量，并且实现每隔一段时间添加新的令牌。最简单的办法当然是每隔一段时间请求一次 Redis，将存储的令牌数量递增。
但实际上我们可以通过对限流两次请求之间的时间和令牌添加速度来计算得出上次请求之后到本次请求时，令牌桶应添加的令牌数量。因此我们在 Redis 中只需要存储上次请求的时间和令牌桶中的令牌数量，而桶的大小和令牌的添加速度可以通过参数传入实现动态修改。
由于第一次运行脚本时默认令牌桶是满的，因此可以将数据的过期时间设置为令牌桶恢复到满所需的时间，及时释放资源。

```lua
-- 获取当前key对应的最后时间和剩余令牌数
local ratelimit_info = redis.pcall('HMGET',KEYS[1],'last_time','current_token')
local last_time = tonumber(ratelimit_info[1])
local current_token = tonumber(ratelimit_info[2])
-- 最大令牌数
local max_token = tonumber(ARGV[1])
-- 时间范围内添加速率
local token_rate = tonumber(ARGV[2])
-- 当前时间
local current_time = tonumber(ARGV[3])
-- 换算公式
local reverse_time = 1000/token_rate
-- 如果是第一次添加令牌
if (current_token == nil) then
  current_token = max_token
  last_time = current_time
else

  -- 间隔时间
  local past_time = current_time-last_time
  -- 间隔时间内应该添加的令牌数
  local reverse_token = math.floor(past_time/reverse_time)
  current_token = current_token+reverse_token
  last_time = reverse_time*reverse_token+last_time
  -- 如果超出最大令牌数，当前令牌数设置为最大令牌数
  if current_token>max_token then
    current_token = max_token
  end
end
local result = 0
if(current_token>0) then
  result = 1
  current_token = current_token-1
end
-- 设置新的桶状态
redis.call('HMSET',KEYS[1],'last_time',last_time,'current_token',current_token)
redis.call('pexpire',KEYS[1],math.ceil(reverse_time*(max_token-current_token)+(current_time-last_time)))
return result
```

通过 RedisTemplate 对象执行脚本：

```java
@Around("@annotation(requestLimiter)")
    public Object around(ProceedingJoinPoint proceedingJoinPoint, RequestLimiter requestLimiter) throws Throwable {

        // 执行 lua 脚本
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        // 指定 lua 脚本
        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("rateLimter.lua")));
        // 指定返回类型
        redisScript.setResultType(Long.class);

        if (log.isDebugEnabled()) {
            log.debug("RateLimterHandler[分布式限流处理器]开始执行限流操作");
        }
        Signature signature = proceedingJoinPoint.getSignature();
        Class<?> exceptionClass = requestLimiter.exceptionClass();
        if (!(signature instanceof MethodSignature)) {
            Constructor<?> constructor = exceptionClass.getConstructor(String.class);
            throw (RuntimeException) constructor.newInstance("the Annotation @RateLimter must used on method!");
        }
        boolean flag = this.rateLimit(redisScript, requestLimiter.key(), requestLimiter.maxPrmits(), requestLimiter.QPS());
        if (!flag) {
            Constructor<?> constructor = exceptionClass.getConstructor(String.class);
            throw (RuntimeException) constructor.newInstance(requestLimiter.exceptionMsg());
        } else {
            log.debug("获取令牌成功");
        }
        return proceedingJoinPoint.proceed();
    }


    public boolean rateLimit(DefaultRedisScript<Long> redisScript, String key, int max, int rate) {
        List<String> keyList = new ArrayList<>(1);
        keyList.add(key);
        return redisTemplate.execute(redisScript, keyList, Integer.toString(max), Integer.toString(rate),
                        Long.toString(System.currentTimeMillis())) == 1;
    }
```

限流方式：

```java
@RequestLimiter(key = "share", QPS = 1, exceptionClass = UserAlertException.class, exceptionMsg = "爆了爆了爆了")
```

## 参考

http://remcarpediem.net/2019/04/06/%E5%9F%BA%E4%BA%8ERedis%E5%92%8CLua%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/

https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673

https://github.com/shmll/shield-ratelimter